/***********************************************************************
 *
 * File: linux/video/stmcoredisplay.h
 * Copyright (c) 2007-2010 STMicroelectronics Limited.
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive for
 * more details.
 *
\***********************************************************************/

#ifndef _STMCOREDISPLAY_H
#define _STMCOREDISPLAY_H

#include <asm/atomic.h>
#include <linux/suspend.h>

#if !defined(_STM_HDMI_DEF)
struct stm_hdmi;
#endif

#define _ALIGN_DOWN(addr,size)  ((addr)&(~((size)-1)))

#define STMCORE_MAX_SOURCES     5
#define STMCORE_MAX_PLANES      9

#define STMCORE_PLANE_VIDEO     (1L<<0)
#define STMCORE_PLANE_GFX       (1L<<1)
#define STMCORE_PLANE_PREFERRED (1L<<2)
#define STMCORE_PLANE_SHARED    (1L<<3)
#define STMCORE_PLANE_MEM_VIDEO (1L<<4)
#define STMCORE_PLANE_MEM_SYS   (1L<<5)
#define STMCORE_PLANE_MEM_ANY   (STMCORE_PLANE_MEM_VIDEO|STMCORE_PLANE_MEM_SYS)

#define STMCORE_NAME_MAX_LENGTH 7

typedef void *stm_vsync_context_handle_t;
typedef void (*stm_vsync_callback) (stm_vsync_context_handle_t  context,
                                    stm_display_timing_events_t field);

struct stmcore_plane_data
{
  int          id;
  unsigned int flags;
};


struct stmcore_vsync_cb
{
  struct list_head           node;
  struct module             *owner;
  stm_vsync_context_handle_t context;
  stm_vsync_callback         cb;
};


struct stmcore_vsync_cb_list
{
  rwlock_t         lock;
  struct list_head list; // of type struct stmcore_vsync_cb
};

typedef enum
{
  STMCORE_VSYNC_STATUS_IDLE,
  STMCORE_VSYNC_STATUS_HARD_IRQ_PROCESSING,
  STMCORE_VSYNC_STATUS_THREADED_IRQ_PROCESSING
} stm_vsync_status_t;



struct stmcore_display
{
  spinlock_t        spinlock;
  /*
   * The vsync wait queue is for public use by any driver needing to
   * block, waiting on the next vsync generated by this display pipeline.
   */
  wait_queue_head_t vsync_wait_queue;
  atomic_t          vsync_count;
  stm_vsync_status_t vsync_status;

  /*
   * For core driver use, if you need a handle to the main output then
   * get your own from the device interface using main_output_id in the
   * platform device data below.
   */
  stm_display_output_h main_output;
  uint32_t             main_output_timing_id;

  /*
   * Allow another driver to hook into the vsync processing.
   */
  struct stmcore_vsync_cb_list vsync_cb_list;

  uint32_t timingevent;

  ktime_t last_irq_begin_time;
  volatile s64 last_display_processing_us;
  volatile s64 min_display_processing_us;
  volatile s64 max_display_processing_us;
  volatile s64 avg_display_processing_us;
  volatile s64 last_display_thread_processing_us; /* IRQ+thread duration */
  volatile s64 min_display_thread_processing_us;
  volatile s64 max_display_thread_processing_us;
  volatile s64 avg_display_thread_processing_us;
};


struct stmcore_source
{
  spinlock_t        spinlock;



  /*
   * The vsync wait queue is for public use by any driver needing to
   * block, waiting on the next vsync generated by this source pipeline.
   */
  wait_queue_head_t source_vsync_wait_queue;
  atomic_t          source_vsync_count;

  /*
   * Allow another driver to hook into the vsync processing.
   */
  struct stmcore_vsync_cb_list source_vsync_cb_list;

  volatile s64 last_source_processing_us;
  volatile s64 min_source_processing_us;
  volatile s64 max_source_processing_us;
  volatile s64 avg_source_processing_us;
};

struct stmcore_source_data
{
  uint32_t              source_id;
  stm_display_source_h  source_handle;
  uint32_t              source_timing_id;
  int                   source_irq;
  char                  source_name[STMCORE_NAME_MAX_LENGTH]; /* for request_irq */

  struct stmcore_source *source_runtime;
};


struct stmcore_display_pipeline_data
{
  struct module            *owner;
  char                     *name;
  int                       vtg_irq;
  char                      vtg_name[STMCORE_NAME_MAX_LENGTH]; /* for request_irq */
  int                       main_output_id;
  int                       hdmi_output_id;
  int                       dvo_output_id;

#if defined(CONFIG_ARCH_STI)
/* Kernel STI */
  struct pinctrl           *dvo_pinctrl;
  struct pinctrl_state     *dvo_pins_default;
#else
  struct stm_pad_config    *dvo_pad_config;
  struct stm_pad_state     *dvo_pad_state;
#endif
  int                       sources_nbr;
  struct stmcore_source_data sources[STMCORE_MAX_SOURCES];

  struct stmcore_plane_data planes[STMCORE_MAX_PLANES];

  const unsigned long      *whitelist;
  unsigned long             whitelist_size;
  unsigned long             io_offset;

  int                       device_id;
  stm_display_device_h      device;
  struct stmcore_display   *display_runtime;
  struct device            *class_device;
  struct platform_device   *pdev;
};


int stmcore_get_display_pipeline(int pipeline, struct stmcore_display_pipeline_data *data);
int stmcore_register_vsync_callback(struct stmcore_display *, struct stmcore_vsync_cb *);
int stmcore_unregister_vsync_callback(struct stmcore_display *, struct stmcore_vsync_cb *);
int stmcore_register_source_vsync_callback(struct stmcore_source *, struct stmcore_vsync_cb *);
int stmcore_unregister_source_vsync_callback(struct stmcore_source *, struct stmcore_vsync_cb *);
int stmcore_display_set_clocks(struct device *dev);

#ifdef DEBUG
#define DPRINTK(a,b...) printk(KERN_WARNING "stmcoredisplay: %s: " a, __FUNCTION__ ,##b)
#define DPRINTK_NOPREFIX(a,b...) printk(a,##b)
#else
#define DPRINTK(a,b...)
#define DPRINTK_NOPREFIX(a,b...)
#endif

#endif /* _STMCOREDISPLAY_H */
