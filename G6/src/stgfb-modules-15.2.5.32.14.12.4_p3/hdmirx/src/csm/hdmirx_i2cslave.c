/***********************************************************************
 *
 * File: hdmirx/src/csm/hdmirx_i2cslave.c
 * Copyright (c) 2012 STMicroelectronics Limited.
 *
 * This file is subject to the terms and conditions of the GNU General Public
 * License.  See the file COPYING in the main directory of this archive for
 * more details.
 *
\***********************************************************************/

#ifdef STHDMIRX_INTERNAL_EDID_SUPPORT

/* Standard Includes ----------------------------------------------*/

/* Include of Other module interface headers ---------------------------*/
/* Local Includes -------------------------------------------------*/
#include <hdmirx_csm.h>
#include <hdmirx_RegOffsets.h>
#include <hdmirx_i2cslave.h>
#include <InternalTypes.h>
/* Private Typedef -----------------------------------------------*/

/* Private Defines ------------------------------------------------*/
#define ENABLE_DBG_I2CSLAVE_INFO

#ifdef ENABLE_DBG_I2CSLAVE_INFO
#define DBG_HDRX_I2CSLAVE_INFO	HDMI_PRINT
#else
#define DBG_HDRX_I2CSLAVE_INFO(a,b...)
#endif

/* Private macro's ------------------------------------------------*/
#define  GET_ADDRS(RegOffSet, PortId)    (I2CSlaveModuleBaseAddrs + (PortId * I2C_SLV_REG_SIZE) + RegOffSet)

/* Private Variables -----------------------------------------------*/
static volatile U32 I2CSlaveModuleBaseAddrs;
static volatile sthdmirx_I2C_slave_control_t I2CSlaveControl;

/* Private functions prototypes ------------------------------------*/

/* Interface procedures & functions ----------------------------------*/

/******************************************************************************
 FUNCTION        : sthdmirx_I2C_slave_init()
 USAGE        	 : Initializes the slaves connected to the Internal EDID(s)
 INPUT        	 : I2C Slave Handle, I2C Slave initialization parameters
 RETURN       	 :
 USED_REGS 	     :
******************************************************************************/
void sthdmirx_I2C_slave_init(sthdmirx_I2C_slave_handle_t *I2CSlaveHandle,
                             sthdmirx_I2C_slave_init_params_t *slInit)
{
  U32 uCtrlWord = 0x00000000;
  U32 PortNum = slInit->PortNo;
  BOOL RegStatus;

  I2CSlaveModuleBaseAddrs = slInit->RegBaseAddrs + I2C_SLAVE_MODULE_BASE_ADDRS;

  DBG_HDRX_I2CSLAVE_INFO("RegBaseAddrs = 0x%x\n", I2CSlaveModuleBaseAddrs)

  if (slInit->bIsClkStretchNeeded)
    {
      uCtrlWord |= I2C_SLV1_CLOCK_STRETCH_EN;
    }
  if (!(slInit->bIsFIFOModeNeeded))  	/* FIFO enabled for both read and write operations */
    {
      uCtrlWord |= (I2C_SLV1_NO_READ_FIFO_MODE | I2C_SLV1_NO_WRITE_FIFO_MODE);
    }

  HDMI_WRITE_REG_DWORD(
    GET_ADDRS(I2C_SLV1_CTRL, PortNum), (uCtrlWord | I2C_SLV1_EN));
  HDMI_WRITE_REG_DWORD(
    GET_ADDRS(I2C_SLV1_IRQ_CTRL, PortNum), I2C_SLV1_IRQ_CTRL_MASK);

  RegStatus = sthdmirx_I2C_register_dev_id(slInit->DevAddress, PortNum);
  if (RegStatus == TRUE)
    I2CSlaveControl.uDevAddress = slInit->DevAddress;

  I2CSlaveControl.PortNo = slInit->PortNo;
  I2CSlaveControl.eI2CSlaveState = I2C_SLAVE_STATE_FREE;
  I2CSlaveHandle = (sthdmirx_I2C_slave_handle_t *) & I2CSlaveControl;

  DBG_HDRX_I2CSLAVE_INFO("I2C Slave device initialized for Port no. %d\n",
                         I2CSlaveControl.PortNo);

  return;
}

/* End of file */
/******************************************************************************
 FUNCTION        : sthdmirx_I2C_slave_operation()
 USAGE        	 : Slave Operations as commanded by the Master
 INPUT        	 : Buffer to Store/Read data, Length of the data
 RETURN       	 : Status of the Slave Operation
 USED_REGS 	     :
******************************************************************************/
BOOL sthdmirx_I2C_slave_operation(U8 *puBuffer, U16 ulLength, U32 PortNum)
{
  U32 I2CSlaveIRQStatus = 0, I2CSlaveStatus = 0, ulTimeOut = 32767;
  U8 DeviceAddrs = 0;
  BOOL OperStatus;

  if ((puBuffer == NULL) || (ulLength <= 0))
    {
      HDMI_PRINT
      ("Error in sthdmirx_I2C_slave_operation - Buffer Parameters Invalid \n");
      HDMI_PRINT(" puBuffer = %d\n ", puBuffer);
      HDMI_PRINT(" ulLength = %d\n ", ulLength);
      HDMI_PRINT(" I2CSlaveContrl.eI2CSlaveState = %d\n",
                 I2CSlaveControl.eI2CSlaveState);
      return FALSE;
    }

  DBG_HDRX_I2CSLAVE_INFO("Waiting for START...\n");
  while (ulTimeOut--)
    {
      I2CSlaveIRQStatus = HDMI_READ_REG_DWORD(
                            GET_ADDRS (I2C_SLV1_IRQ_STATUS, PortNum));
      I2CSlaveStatus = HDMI_READ_REG_DWORD(
                         GET_ADDRS(I2C_SLV1_STATUS, PortNum));

      if ((I2CSlaveIRQStatus & I2C_SLV1_START) &&
          (I2CSlaveIRQStatus & I2C_SLV1_DEV_ID_RECEIVED))
        {
          /* This means a START has been generated by the Master, so get the device address */
          I2CSlaveControl.eI2CSlaveState = I2C_SLAVE_STATE_START;
          DeviceAddrs = (U8) (HDMI_READ_REG_DWORD(
                                GET_ADDRS(I2C_SLV1_RX_DEV_ID, PortNum)) & I2C_SLV1_DATA_MASK);

          DBG_HDRX_I2CSLAVE_INFO("Device Address = 0x%x\n", DeviceAddrs, 0);
          DBG_HDRX_I2CSLAVE_INFO("Slave Control Dev ID = 0x%x\n",
                                 I2CSlaveControl.uDevAddress);

          if (I2CSlaveControl.uDevAddress != (DeviceAddrs & I2C_SLAVE_DEVICEID_MASK))
            {
              I2CSlaveControl.eI2CSlaveState = I2C_SLAVE_STATE_DATA_ERROR;
              DBG_HDRX_I2CSLAVE_INFO
              ("Error in sthdmirx_I2C_slave_operation - Invalid Device Address  - %x\n",
               DeviceAddrs);
              return FALSE;
            }

          /* Determine now if the operation is a READ or a WRITE */
          if (DeviceAddrs & I2C_SLAVE_ADDR_READ_MASK)
            {
              U8 BytesPerPage = 0, TotalBytes = 0;
              /* Operation is a Read from Slave */
              I2CSlaveControl.uTransactionDir = I2C_SLAVE_DIR_READ;

              while (TotalBytes < 128)
                {
                  BytesPerPage = sthdmirx_I2C_read_from_slaveFIFO(
                                   puBuffer + TotalBytes, BytesPerPage,
                                   (DeviceAddrs & I2C_SLAVE_DEVICEID_MASK), PortNum);
                  TotalBytes += BytesPerPage;
                }

              printf("IRQ Status After = %x\n",
                     HDMI_READ_REG_DWORD(
                       GET_ADDRS(I2C_SLV1_IRQ_STATUS, PortNum)));
              printf("IN FIFO CNTR After = %x\n",
                     HDMI_READ_REG_DWORD(
                       GET_ADDRS (I2C_SLV1_IN_FIFO_CNTR, PortNum)));
              /* Reset the I2C Slave for the connected port */
              sthdmirx_I2C_slave_reset(PortNum);
              return TRUE;
            }
          else
            {
              /* Operation is a Write to Slave */
              I2CSlaveControl.uTransactionDir = I2C_SLAVE_DIR_WRITE;
              OperStatus = sthdmirx_I2C_write_to_slaveFIFO(
                             puBuffer, ulLength, (DeviceAddrs&I2C_SLAVE_DEVICEID_MASK),
                             PortNum);
              return OperStatus;
            }
        }
      else
        {
          printf("START Not received yet... \n");
        }
    }
  return FALSE;
}

/******************************************************************************
 FUNCTION      : sthdmirx_I2C_read_from_slaveFIFO()
 USAGE        	 : Slave Read as per Master from the Write FIFO
 INPUT        	 : Buffer to Read data into, Length of the data
 RETURN       	 : Status of the Slave Read Operation
 USED_REGS 	 :
******************************************************************************/
U8 sthdmirx_I2C_read_from_slaveFIFO(U8 *puBuffer, U16 ulLength, U8 DeviceAddrs,
                                    U32 PortNum)
{
  U32 ulSlaveIRQStatus = 0;
  S32 sWriteFIFOLength = 0, i;
  U8 *pulocbuf = puBuffer;
  U8 sBytesFilled = 0;

  /* Get the OUT FIFO length */
  sWriteFIFOLength = HDMI_READ_REG_DWORD(
                       GET_ADDRS(I2C_SLV1_OUT_FIFO_CNTR, PortNum));

  /* Keep polling the Almost Empty Interrupt to refill the Input FIFO */
  ulSlaveIRQStatus = HDMI_READ_REG_DWORD(
                       GET_ADDRS(I2C_SLV1_IRQ_STATUS, PortNum));

  if (ulSlaveIRQStatus &
      (I2C_SLV1_STRETCH_OUT | I2C_SLV1_START | I2C_SLV1_DEV_ID_RECEIVED))
    {
      S32 sEmptySpace;
      DBG_HDRX_I2CSLAVE_INFO("WRITE FIFO being refilled \n");
      sWriteFIFOLength =
        HDMI_READ_REG_DWORD(GET_ADDRS(I2C_SLV1_OUT_FIFO_CNTR, PortNum));
      sEmptySpace = 16 - sWriteFIFOLength;

      if (sEmptySpace != 0)
        {
          for (i = 0; i < sEmptySpace; i++)
            {
              HDMI_WRITE_REG_DWORD(
                GET_ADDRS(I2C_SLV1_DATA, PortNum), *pulocbuf++);
              sBytesFilled++;
            }
          ulSlaveIRQStatus = HDMI_READ_REG_DWORD(
                               GET_ADDRS(I2C_SLV1_IRQ_STATUS, PortNum));
          if (ulSlaveIRQStatus & I2C_SLV1_STOP)
            {
              /* Write '1' to the first 4 bits of the IRQ Status register */
              HDMI_WRITE_REG_DWORD(
                GET_ADDRS(I2C_SLV1_IRQ_STATUS, PortNum), 0xF);
            }
        }
      else
        {
          DBG_HDRX_I2CSLAVE_INFO("WRITE FIFO not empty \n");
          return 0;
        }
      DBG_HDRX_I2CSLAVE_INFO("%d Bytes written to the READ FIFO \n",
                             sBytesFilled, 0);
    }
  else
    {
      DBG_HDRX_I2CSLAVE_INFO("Not ready to refill data into WRITE FIFO \n");
      return 0;
    }
  return sBytesFilled;
}

/******************************************************************************
 FUNCTION      : sthdmirx_I2C_write_to_slaveFIFO()
 USAGE        	 : Slave Write as per Master to the Read FIFO
 INPUT        	 : Buffer to Write data into, Length of the data
 RETURN       	 : Status of the Slave Write Operation
 USED_REGS 	 :
******************************************************************************/
BOOL sthdmirx_I2C_write_to_slaveFIFO(U8 *puBuffer, U16 ulLength,
                                     U8 DeviceAddrs, U32 PortNum)
{
  U8 ubBytes;

  DBG_HDRX_I2CSLAVE_INFO("WRITE to Slave \n");

  /* Display the data the master writes into Slave */
  ubBytes = HDMI_READ_REG_DWORD(GET_ADDRS(I2C_SLV1_IN_FIFO_CNTR, PortNum));
  while (ubBytes--)
    {
      printf("Byte %d = %x \n", ubBytes,
             HDMI_READ_REG_DWORD(GET_ADDRS(I2C_SLV1_DATA, PortNum)));
    }

  /* Reset the I2C Slave for the connected port */
  sthdmirx_I2C_slave_reset(PortNum);

  return TRUE;
}

/******************************************************************************
 FUNCTION      : sthdmirx_I2C_slave_reset()
 USAGE        	 : I2C Slave Reset
 INPUT        	 : Device Address, Port Id
 RETURN       	 :
 USED_REGS 	 :
******************************************************************************/
void sthdmirx_I2C_slave_reset(U8 PortNum)
{
  U32 ulCtrlWord = 0x0;

  /* Reset the I2C Slave, so that it is ready for the next transaction */
  HDMI_WRITE_REG_DWORD(GET_ADDRS(I2C_SLV1_CTRL, PortNum), ulCtrlWord);

  /* Enable the I2C Slave again with strecting */
  ulCtrlWord = (I2C_SLV1_EN | I2C_SLV1_CLOCK_STRETCH_EN);
  HDMI_WRITE_REG_DWORD(GET_ADDRS(I2C_SLV1_CTRL, PortNum), ulCtrlWord);

  DBG_HDRX_I2CSLAVE_INFO("I2C Slave for Port %d Reset \n", PortNum);
  return;
}

/******************************************************************************
 FUNCTION      : sthdmirx_I2C_register_dev_id()
 USAGE        	 : Register Device id to the Slave specified
 INPUT        	 : Device Address, Port Id
 RETURN       	 : Status of the Operation
 USED_REGS 	 :
******************************************************************************/
BOOL sthdmirx_I2C_register_dev_id(U8 DeviceAddrs, U8 PortNum)
{
  U32 ulPinNum;
  U32 ulBitstoSet;

  ulPinNum = DeviceAddrs >> 1;
  ulBitstoSet = (ulPinNum % I2C_SLAVE_REG_TABLE_BITS);

  HDMI_SET_REG_BITS_DWORD(GET_ADDRS(
                            (I2C_SLV1_ADDR_TBL0 + ((ulPinNum / I2C_SLAVE_REG_TABLE_BITS) * 4)), PortNum),
                          (1 << ulBitstoSet));

  DBG_HDRX_I2CSLAVE_INFO
  ("sthdmirx_I2C_register_dev_id - Device Id 0x%x Registered \n",
   DeviceAddrs);
  return TRUE;
}

/******************************************************************************
 FUNCTION   : sthdmirx_I2C_unregister_dev_id()
 USAGE      : UnRegister Device id to the Slave specified
 INPUT      : Device Address, Port Id
 RETURN     : Status of the Operation
 USED_REGS 	:
******************************************************************************/
BOOL sthdmirx_I2C_unregister_dev_id(U8 DeviceAddrs, U8 PortNum)
{
  U32 ulPinNum;
  U32 ulBitstoSet;

  ulPinNum = DeviceAddrs >> 1;
  ulBitstoSet = (ulPinNum % I2C_SLAVE_REG_TABLE_BITS);

  HDMI_CLEAR_REG_BITS_DWORD(GET_ADDRS(
                              (I2C_SLV1_ADDR_TBL0 + ((ulPinNum / I2C_SLAVE_REG_TABLE_BITS) *4)), PortNum),
                            ulBitstoSet);

  DBG_HDRX_I2CSLAVE_INFO
  ("sthdmirx_I2C_unregister_dev_id - Device Id 0x%x UnRegistered \n",
   DeviceAddrs);
  return TRUE;
}

#endif /*STHDMIRX_INTERNAL_EDID_SUPPORT,  End of file */
