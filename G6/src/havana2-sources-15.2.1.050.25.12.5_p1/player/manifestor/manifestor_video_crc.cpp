/************************************************************************
Copyright (C) 2003-2014 STMicroelectronics. All Rights Reserved.

This file is part of the Streaming Engine.

Streaming Engine is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

Streaming Engine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Streaming Engine; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

The Streaming Engine Library may alternatively be licensed under a
proprietary license from ST.
************************************************************************/

#include "player_generic.h"
#include "player_playback.h"
#include "player_stream.h"
#include "st_relayfs_se.h"
#include "manifestor_video_crc.h"

#undef TRACE_TAG
#define TRACE_TAG   "Manifestor_VideoCRC_c"

// aliasing video grab group for video crc group..
#define group_manifestor_video_crc group_manifestor_video_grab

// Used for SW-CRC/Relay
extern "C" int snprintf(char *buf, long size, const char *fmt, ...) __attribute__((format(printf, 3, 4))) ;

//{{{  Constructor
// /////////////////////////////////////////////////////////////////////////
//
//      Constructor :
//      Action  : Initialise state
//      Input   :
//      Output  :
//      Result  :
//

Manifestor_VideoCRC_c::Manifestor_VideoCRC_c(void)
    : Manifestor_Video_c()
{
    if (InitializationStatus != ManifestorNoError)
    {
        SE_ERROR("Initialization status not valid - aborting init\n");
        return;
    }

    SE_DEBUG(group_manifestor_video_crc, "\n");

    SetGroupTrace(group_manifestor_video_crc);

    Configuration.Capabilities = MANIFESTOR_CAPABILITY_CRC;
}
//}}}
//{{{  Destructor
// /////////////////////////////////////////////////////////////////////////
//
//      Destructor :
//      Action  : Give up switch off the lights and go home
//      Input   :
//      Output  :
//      Result  :
//

Manifestor_VideoCRC_c::~Manifestor_VideoCRC_c(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
}
//}}}
//{{{  Halt
//{{{  doxynote
/// \brief              Shutdown, stop presenting and retrieving frames
///                     don't return until complete
//}}}
ManifestorStatus_t      Manifestor_VideoCRC_c::Halt(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
    return Manifestor_Video_c::Halt();
}
//}}}
//{{{  Reset
/// \brief              Reset all state to initial values
ManifestorStatus_t Manifestor_VideoCRC_c::Reset(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");

    if (TestComponentState(ComponentRunning))
    {
        Halt();
    }

    return Manifestor_Video_c::Reset();
}
//}}}
//{{{  FlushDisplayQueue
//{{{  doxynote
/// \brief      Flushes the display queue so buffers not yet manifested are returned
//}}}
ManifestorStatus_t      Manifestor_VideoCRC_c::FlushDisplayQueue(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");

    return ManifestorNoError;
}
//}}}
//{{{  QueueBuffer
//{{{  doxynote
/// \brief                      Actually put buffer on display
/// \param BufferIndex          Index into array of stream buffers
/// \param FrameParameters      Frame parameters generated by frame parser
/// \param VideoParameters      Display positioning information generated by frame parser
/// \param VideoOutputTiming    Display timing information generated by output timer
/// \return                     Success or fail
//}}}
ManifestorStatus_t Manifestor_VideoCRC_c::QueueBuffer(unsigned int                        BufferIndex,
                                                      struct ParsedFrameParameters_s     *FrameParameters,
                                                      struct ParsedVideoParameters_s     *VideoParameters,
                                                      struct ManifestationOutputTiming_s *VideoOutputTiming,
                                                      Buffer_t                            Buffer)
{
    /* SW CRC Calculation */
    if (IsSoftwareCRCEnabled())
    {
        Relay_SW_CRC(Buffer, VideoParameters, (unsigned int) FrameParameters->NativePlaybackTime);
    }

    return ManifestorError;
}
//}}}
//{{{  UpdateOutputSurfaceDescriptor
//{{{  doxynote
/// \brief      Find out information about display plane and output
/// \return     ManifestorNoError if done successfully
//}}}
ManifestorStatus_t Manifestor_VideoCRC_c::UpdateOutputSurfaceDescriptor(void)
{
    // Supply some defaults
    SurfaceDescriptor[0].StreamType                = StreamTypeVideo;
    SurfaceDescriptor[0].ClockPullingAvailable     = false;
    SurfaceDescriptor[0].PercussiveCapable         = true;
    SurfaceDescriptor[0].DisplayWidth              = 1920;
    SurfaceDescriptor[0].DisplayHeight             = 1080;
    SurfaceDescriptor[0].Progressive               = true;
    SurfaceDescriptor[0].FrameRate                 = Rational_t(25, 1);
    // But request that we set output to match input rates
    SurfaceDescriptor[0].InheritRateAndTypeFromSource = true;
    return ManifestorNoError;
}
//}}}
//{{{  Enable
// ///////////////////////////////////////////////////////////////////////////////////////
//    Enable
//

ManifestorStatus_t Manifestor_VideoCRC_c::Enable(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
    Visible     = true;
    return ManifestorNoError;
}
//}}}
//{{{  Disable
// ///////////////////////////////////////////////////////////////////////////////////////
//    Disable
//

ManifestorStatus_t Manifestor_VideoCRC_c::Disable(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
    Visible             = false;
    return ManifestorNoError;
}
//}}}
//{{{  GetEnable
// ///////////////////////////////////////////////////////////////////////////////////////
//    GetEnable
//

bool Manifestor_VideoCRC_c::GetEnable(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
    return Visible;
}
//}}}
//{{{  CloseOutputSurface
//{{{  doxynote
/// \brief              Release all frame buffer resources
//}}}
ManifestorStatus_t Manifestor_VideoCRC_c::CloseOutputSurface(void)
{
    SE_DEBUG(group_manifestor_video_crc, "\n");
    return ManifestorNoError;
}
//}}}
//{{{  OpenOutputSurface
//{{{  doxynote
/// \brief      Find out information about display plane and output and use it to
///             open handles to the desired display plane
/// \param      Device Handle of the display device.
/// \return     ManifestorNoError if plane opened successfully
//}}}
ManifestorStatus_t Manifestor_VideoCRC_c::OpenOutputSurface(void *Device)
{
    SE_DEBUG(group_manifestor_video_crc, "DisplayDevice %p\n", Device);
    Visible             = false;
    return ManifestorNoError;
}
//}}}

ManifestorStatus_t Manifestor_VideoCRC_c::Relay_SW_CRC_Write(char PictureType, unsigned int LumaCRC, unsigned int ChromaCRC, unsigned int playbacktime)
{
    char        buffer_relay[96];
    // Playback time in Milliseconds, PictureType, CRC's in hex
    /* This format matches the STAPI CRC logs */
    snprintf(buffer_relay, sizeof(buffer_relay), "%x %c %u %u\n", playbacktime, PictureType, (unsigned int)LumaCRC, (unsigned int)ChromaCRC);
    buffer_relay[sizeof(buffer_relay) - 1] = '\0';

    SE_DEBUG(group_manifestor_video_crc, "%s", buffer_relay);
    st_relayfs_write_se(ST_RELAY_TYPE_SWCRC + RelayfsIndex, ST_RELAY_SOURCE_SE,
                        (unsigned char *)buffer_relay, strlen(buffer_relay), NULL);
    return ManifestorNoError;
}


//{{{  Relay_SW_CRC
/// \brief                     Extract specific parameters to give to generic Manifestor->CalcSWCRC and relay the returned value with specific format
ManifestorStatus_t  Manifestor_VideoCRC_c::Relay_SW_CRC(Buffer_t   Buffer,
                                                        struct ParsedVideoParameters_s *ParsedVideoParameters,
                                                        unsigned int playbacktime)
{
    unsigned int LumaCRC = 0xffffffff, ChromaCRC = 0xffffffff;
    unsigned int Width = ParsedVideoParameters->Content.Width;
    unsigned int Height = ParsedVideoParameters->Content.Height;
    unsigned char *LumaAddress, *CbAddress, *CrAddress;
    OS_PhysAddr_t LumaPhysical, CbPhysical;
    unsigned int LumaSize, ChromaSize;
    LumaAddress = Stream->GetDecodeBufferManager()->Luma(Buffer, PrimaryManifestationComponent, CachedAddress);
    CbAddress = Stream->GetDecodeBufferManager()->Chroma(Buffer, PrimaryManifestationComponent, CachedAddress);
    CrAddress = Stream->GetDecodeBufferManager()->Chroma(Buffer, PrimaryManifestationComponent, CachedAddress);
    LumaPhysical = (OS_PhysAddr_t)Stream->GetDecodeBufferManager()->Luma(Buffer, PrimaryManifestationComponent, PhysicalAddress);
    CbPhysical = (OS_PhysAddr_t)Stream->GetDecodeBufferManager()->Chroma(Buffer, PrimaryManifestationComponent, PhysicalAddress);
    LumaSize   = Stream->GetDecodeBufferManager()->LumaSize(Buffer, PrimaryManifestationComponent);
    ChromaSize = Stream->GetDecodeBufferManager()->ChromaSize(Buffer, PrimaryManifestationComponent);
    OS_PurgeCacheRange(LumaAddress, LumaPhysical, LumaSize);
    OS_PurgeCacheRange(CbAddress, CbPhysical, ChromaSize);

    // golden reference are non-cropped picture CRC - to be removed when cropped golden reference generated
    if (Height == 1080)
    {
        Height = 1088;
    }

    // determine CRC type : Frame, top, bottom from display scan type
    if (!ParsedVideoParameters->InterlacedFrame)
    {
        /* Frame not MBAFF */
        CalcSWCRC(Stream->GetDecodeBufferManager()->ComponentDataType(PrimaryManifestationComponent) , Width, Height,
                  StructureFrame, LumaAddress, CbAddress, CrAddress , &LumaCRC, &ChromaCRC);
        Relay_SW_CRC_Write('F', LumaCRC, ChromaCRC, playbacktime);
    }
    else
    {
        /* Top Field */
        CalcSWCRC(Stream->GetDecodeBufferManager()->ComponentDataType(PrimaryManifestationComponent) , Width, Height,
                  StructureTopField, LumaAddress, CbAddress, CrAddress , &LumaCRC, &ChromaCRC);
        Relay_SW_CRC_Write('T', LumaCRC, ChromaCRC, playbacktime);
        /* Bottom Field */
        CalcSWCRC(Stream->GetDecodeBufferManager()->ComponentDataType(PrimaryManifestationComponent) , Width, Height,
                  StructureBottomField, LumaAddress, CbAddress, CrAddress , &LumaCRC, &ChromaCRC);
        Relay_SW_CRC_Write('B', LumaCRC, ChromaCRC, playbacktime);
    }

    return ManifestorNoError;
}
//}}}
