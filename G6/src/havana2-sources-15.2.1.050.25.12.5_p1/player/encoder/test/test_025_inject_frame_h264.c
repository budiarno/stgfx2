/************************************************************************
Copyright (C) 2003-2013 STMicroelectronics. All Rights Reserved.

This file is part of the Streaming Engine.

Streaming Engine is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

Streaming Engine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with Streaming Engine; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.

The Streaming Engine Library may alternatively be licensed under a
proprietary license from ST.
************************************************************************/
#include "encoder_test.h"
#include "common.h"

#include <linux/delay.h>

// For Jiffies/
#include <linux/sched.h>

// For checking returned buffers
#include <linux/crc32.h>

#include <linux/delay.h>

#include "stm_memsrc.h"
#include "stm_memsink.h"

#include "video_buffer_traffic320yuv.h"
// video_buffer_traffic320yuv defines the following:
#define VIDEO_WIDTH       TRAFFIC_VIDEO_WIDTH
#define VIDEO_HEIGHT      TRAFFIC_VIDEO_HEIGHT
#define VIDEO_BUFFER_SIZE TRAFFIC_VIDEO_BUFFER_SIZE
#define VIDEO_SURFACE_FORMAT TRAFFIC_VIDEO_SURFACE_FORMAT

// Raster formats = bytes per pixel - all planar formats = 1
// Planar formats = total plane size as 2xfactor of main plane - all raster format = 2
// Width Alignment (bytes)
// Height Alignment (bytes) - obtained from SE DecodedBufferManager

static const int LUT[14][4] =
{
    {1, 2, 1,  1}, //    SURFACE_FORMAT_UNKNOWN,
    {1, 2, 1,  1}, //    SURFACE_FORMAT_MARKER_FRAME,
    {1, 2, 1,  1}, //    SURFACE_FORMAT_AUDIO,
    {1, 3, 16, 32},//    SURFACE_FORMAT_VIDEO_420_MACROBLOCK,
    {1, 3, 16, 32},//    SURFACE_FORMAT_VIDEO_420_PAIRED_MACROBLOCK,
    {2, 2, 4,  1}, //    SURFACE_FORMAT_VIDEO_422_RASTER,
    {1, 3, 2,  16}, //    SURFACE_FORMAT_VIDEO_420_PLANAR,
    {1, 3, 2,  16}, //    SURFACE_FORMAT_VIDEO_420_PLANAR_ALIGNED,
    {1, 4, 2,  16}, //    SURFACE_FORMAT_VIDEO_422_PLANAR,
    {4, 2, 4,  32}, //    SURFACE_FORMAT_VIDEO_8888_ARGB,
    {3, 2, 4,  32}, //    SURFACE_FORMAT_VIDEO_888_RGB,
    {2, 2, 2,  32}, //    SURFACE_FORMAT_VIDEO_565_RGB,
    {2, 2, 4,  32}, //    SURFACE_FORMAT_VIDEO_422_YUYV,
    {1, 3, 4,  32}, //    SURFACE_FORMAT_VIDEO_420_RASTER2B - Alignment may not be true in practice if input buffer not from decoder
};

// Some locals
#define FHD_WIDTH       1920
#define FHD_HEIGHT      1088
#define SD_WIDTH         720
#define VIDEO_FRAME_RATE_NUM (25)
#define VIDEO_FRAME_RATE_DEN (1)
#define TIME_PER_FRAME ((1000*VIDEO_FRAME_RATE_DEN)/VIDEO_FRAME_RATE_NUM)

// Determine the output frame size....
#define VIDEO_PITCH     (((VIDEO_WIDTH*LUT[VIDEO_SURFACE_FORMAT][0] + LUT[VIDEO_SURFACE_FORMAT][2]-1)/LUT[VIDEO_SURFACE_FORMAT][2])*LUT[VIDEO_SURFACE_FORMAT][2])
#define VIDEO_BUFFER_HEIGHT     (((VIDEO_HEIGHT + LUT[VIDEO_SURFACE_FORMAT][3]-1)/LUT[VIDEO_SURFACE_FORMAT][3])*LUT[VIDEO_SURFACE_FORMAT][3])
#define VIDEO_FRAME_SIZE    ((VIDEO_PITCH*VIDEO_BUFFER_HEIGHT*LUT[VIDEO_SURFACE_FORMAT][1])/2)
#define TEST_BUFFER_SIZE    (FHD_WIDTH*FHD_HEIGHT*3/2) //min(VIDEO_FRAME_SIZE, VIDEO_BUFFER_SIZE)
#define VERTICAL_ALIGNMENT  (LUT[VIDEO_SURFACE_FORMAT][3])

#define COMPRESSED_BUFFER_SIZE  FHD_WIDTH*FHD_HEIGHT
#define VIDEO_BITRATE_MODE STM_SE_CTRL_VALUE_BITRATE_CONTROL_MODE_VBR
//#define VIDEO_BITRATE_MODE -1 //Fix qp
#define VIDEO_BITRATE 4000000
#define VIDEO_CPB_BUFFER_SIZE (VIDEO_BITRATE*2)

//#define DUMP_INPUT_BUFFER
//#define DUMP_OUTPUT_BUFFER

#define PTS_TIME_SCALE 90000
#define INJECT_COUNT 10

typedef enum
{
    LL_Level,
    LL_MaxMBPS,
    LL_MaxFS,
    LL_MaxBR,
    LL_MaxCPB,
    LL_MinCR,
} level_limits_type_index_t;

// level limits, from H264 Table A.1
// (level) (Max MB per second) (Max frame size) (max bitrate)  (max CPB size) (Min comp ratio)
const unsigned int LevelLimits[][6] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0,    1485,    99,     64,    175, 2 }, // 1.0  [0]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B,    1485,    99,    128,    350, 2 }, // 1.0b [1]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1,    3000,   396,    192,    500, 2 }, // 1.1  [2]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2,    6000,   396,    384,   1000, 2 }, // 1.2  [3]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3,   11880,   396,    768,   2000, 2 }, // 1.3  [4]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0,   11880,   396,   2000,   2000, 2 }, // 2.0  [5]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1,   19800,   792,   4000,   4000, 2 }, // 2.1  [6]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2,   20250,  1620,   4000,   4000, 2 }, // 2.2  [7]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0,   40500,  1620,  10000,  10000, 2 }, // 3.0  [8]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1,  108000,  3600,  14000,  14000, 4 }, // 3.1  [9]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2,  216000,  5120,  20000,  20000, 4 }, // 3.2  [10]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0,  245760,  8192,  20000,  25000, 4 }, // 4.0  [11]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1,  245760,  8192,  50000,  62500, 2 }, // 4.1  [12]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2,  522240,  8704,  50000,  62500, 2 }, // 4.2  [13]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0,  589824, 22080, 135000, 135000, 2 }, // 5.0  [14]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1,  983040, 36864, 240000, 240000, 2 }, // 5.1  [15]
    { STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, 2073600, 36864, 240000, 240000, 2 }  // 5.2  [16]
};

// Level limits by resolution
#define QCIF_WIDTH            176
#define QCIF_HEIGHT           144
#define CIF_WIDTH             352
#define CIF_HEIGHT            288
#define HHR_625_WIDTH         352
#define HHR_625_HEIGHT        576
#define SD_625_WIDTH          720
#define SD_625_HEIGHT         576
#define HD_WIDTH             1280
#define HD_HEIGHT             720
#define SXGA_WIDTH           1280
#define SXGA_HEIGHT          1024
#define UHD_2Kx1K_WIDTH      2048
#define UHD_2Kx1K_HEIGHT     1024
#define UHD_2Kx1080_WIDTH    2048
#define UHD_2Kx1080_HEIGHT   1088
#define UHD_3672x1536_WIDTH  3680
#define UHD_3672x1536_HEIGHT 1536
#define UHD_4096x2304_WIDTH  4096
#define UHD_4096x2304_HEIGHT 2304

// METADATA VS CONTROL VALUE
static const int32_t GOOD_H264_OUTPUT_FRAMERATE[][2] =
{
    {25, 1},
    {60, 1},
    {30, 1},
    {24, 1},
};

static const int32_t BAD_H264_OUTPUT_FRAMERATE[][2] =
{
    {60000, 1001},
    {30000, 1001},
    {24000, 1001},
};

typedef enum
{
    TESTED_Profile,
    TESTED_Level,
    TESTED_Width,
    TESTED_Height,
} tested_type_index_t;

static const int32_t GOOD_H264_LEVEL_VS_FS[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t BAD_H264_LEVEL_VS_FS[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, SXGA_WIDTH, SXGA_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, FHD_WIDTH, FHD_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t GOOD_H264_LEVEL_VS_BR[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t BAD_H264_LEVEL_VS_BR[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t GOOD_H264_LEVEL_VS_CPB[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t BAD_H264_LEVEL_VS_CPB[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_BASELINE, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t GOOD_H264_LEVEL_VS_MBPS[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static const int32_t BAD_H264_LEVEL_VS_MBPS[][5] =
{
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_0, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_B, QCIF_WIDTH, QCIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_1, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_2, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_1_3, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_0, CIF_WIDTH, CIF_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_1, HHR_625_WIDTH, HHR_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_2_2, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_0, SD_625_WIDTH, SD_625_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_1, HD_WIDTH, HD_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_3_2, SXGA_WIDTH, SXGA_HEIGHT },
    /*{ STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_0, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_1, UHD_2Kx1K_WIDTH, UHD_2Kx1K_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_4_2, UHD_2Kx1080_WIDTH, UHD_2Kx1080_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_0, UHD_3672x1536_WIDTH, UHD_3672x1536_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_1, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },
    { STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH, STM_SE_CTRL_VALUE_VIDEO_H264_LEVEL_IDC_5_2, UHD_4096x2304_WIDTH, UHD_4096x2304_HEIGHT },*/
};

static int GetLevelIndex(int levelIdc)
{
    int i = 0;
    for (i = 0 ; i < sizeof(LevelLimits) / sizeof(LevelLimits[0]) ; i++)
    {
        if (LevelLimits[i][LL_Level] == levelIdc)
        {
            break;
        }
    }
    return i;
}

static int GetCpbNalFactor(uint32_t profileIdc)
{
    if ((profileIdc == STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH)     ||
        (profileIdc == STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH_10)  ||
        (profileIdc == STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH_422) ||
        (profileIdc == STM_SE_CTRL_VALUE_VIDEO_H264_PROFILE_IDC_HIGH_444))
    {
        return 1200;
    }
    else
    {
        return 1500;
    }
}

/* Return: -1: fail; 0: pass 1: EOS */
static int PullCompressedEncode(pp_descriptor *memsinkDescriptor)
{
    int retval = 0;
    stm_se_capture_buffer_t *p_memsink_pull_buffer;
    u32 crc = 0;
    int loop = 0;

    //Wait for encoded frame to be available for memsink
    do
    {
        loop ++;
        memsinkDescriptor->m_availableLen = 0;
        retval = stm_memsink_test_for_data(memsinkDescriptor->obj, &memsinkDescriptor->m_availableLen);

        if (retval && (-EAGAIN != retval))
        {
            pr_err("%s stm_memsink_test_for_data failed (%d)\n", __func__, retval);
            return -1;
        }

        mdelay(1); //in ms

        if (loop == 100)
        {
            pr_err("PullCompressedEncode : Nothing available\n");
            return -1;
        }
    }
    while (-EAGAIN == retval);

    //
    // setup memsink_pull_buffer
    //
    p_memsink_pull_buffer = (stm_se_capture_buffer_t *)memsinkDescriptor->m_Buffer;
    p_memsink_pull_buffer->physical_address = NULL;
    p_memsink_pull_buffer->virtual_address  = &memsinkDescriptor->m_Buffer      [sizeof(stm_se_capture_buffer_t)];
    p_memsink_pull_buffer->buffer_length    = COMPRESSED_BUFFER_SIZE           - sizeof(stm_se_capture_buffer_t);
    retval = stm_memsink_pull_data(memsinkDescriptor->obj,
                                   p_memsink_pull_buffer,
                                   p_memsink_pull_buffer->buffer_length,
                                   &memsinkDescriptor->m_availableLen);

    if (retval != 0)
    {
        pr_err("PullCompressedEncode : stm_memsink_pull_data fails (%d)\n", retval);
        return -1;
    }

    // Check for EOS
    if (p_memsink_pull_buffer->u.compressed.discontinuity & STM_SE_DISCONTINUITY_EOS)
    {
        pr_info("%s EOS Detected! discontinuity 0x%x\n", __func__, p_memsink_pull_buffer->u.compressed.discontinuity);
        return 1;
    }

#ifdef DUMP_OUTPUT_BUFFER
    print_hex_dump(KERN_INFO, "OUTPUT BUFFER DUMP IN HEXADECIMAL: ", DUMP_PREFIX_OFFSET, 16, 1,
                   p_memsink_pull_buffer->virtual_address, min((unsigned) 64, memsinkDescriptor->m_availableLen), true);
#endif
    crc = crc32_be(crc, p_memsink_pull_buffer->virtual_address, memsinkDescriptor->m_availableLen);
    pr_info("CRC Value of this frame pull is 0x%08x\n", crc);
    return 0;
}

static int init_stream(EncoderContext *pContext)
{
    int result = 0;

    // Create a MemSink
    result = stm_memsink_new("EncoderVideoSink", STM_IOMODE_BLOCKING_IO, KERNEL, (stm_memsink_h *)&gVideoTest[0].Sink.obj);
    if (result < 0)
    {
        pr_err("Error: %s Failed to create a new memsink\n", __func__);
        return result;
    }

    // Create Stream
    result = stm_se_encode_stream_new("EncodeStream0", pContext->encode, STM_SE_ENCODE_STREAM_ENCODING_VIDEO_H264, &pContext->video_stream[0]);
    if (result < 0)
    {
        pr_err("Error: %s Failed to create a new STM_SE_ENCODE_STREAM_ENCODING_VIDEO_H264 EncodeStream\n", __func__);
        goto stream_new_fail;
    }

    // Attach the memsink
    result = stm_se_encode_stream_attach(pContext->video_stream[0], gVideoTest[0].Sink.obj);
    if (result < 0)
    {
        pr_err("Error: %s Failed to attach encode stream to memsink for video\n", __func__);
        goto stream_attach_fail;
    }

    result = VideoEncodeEventSubscribe(pContext);
    if (result < 0)
    {
        pr_err("%s - VideoEncodeEventSubscribe failed\n", __func__);
        goto subscribe_fail;
    }

    // STM_SE_CTRL_ENCODE_STREAM_BITRATE_MODE Control
    result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE_MODE, VIDEO_BITRATE_MODE);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
        goto set_control_fail;
    }

    // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
    result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, VIDEO_BITRATE);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
        goto set_control_fail;
    }

    // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
    result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, VIDEO_CPB_BUFFER_SIZE);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
        goto set_control_fail;
    }

    return 0;

set_control_fail:
    VideoEncodeEventUnsubscribe(pContext);
subscribe_fail:
    if (stm_se_encode_stream_detach(pContext->video_stream[0], gVideoTest[0].Sink.obj)) {};
stream_attach_fail:
    if (stm_se_encode_stream_delete(pContext->video_stream[0])) {};
stream_new_fail:
    if (stm_memsink_delete((stm_memsink_h)gVideoTest[0].Sink.obj)) {};

    return result;
}

static int deinit_stream(EncoderContext *pContext)
{
    int result = 0;

    result = stm_se_encode_stream_inject_discontinuity(pContext->video_stream[0], STM_SE_DISCONTINUITY_EOS);
    if (result < 0)
    {
        pr_err("Error: %s Failed to inject discontinuity EOS\n", __func__);
        goto fail_inject_discontinuity;
    }

    result = PullCompressedEncode(&gVideoTest[0].Sink);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on testing pull compressed frame\n", __func__);
        goto fail_inject_discontinuity;
    }

    result = VideoEncodeEventUnsubscribe(pContext);
    if (result < 0)
    {
        pr_err("%s - VideoEncodeEventUnsubscribe failed\n", __func__);
        goto unsubscribe_fail;
    }

    result = stm_se_encode_stream_detach(pContext->video_stream[0], gVideoTest[0].Sink.obj);
    if (result < 0)
    {
        pr_err("Error: %s Failed to detach encode stream from memsink\n", __func__);
        goto fail_stream_detach;
    }

    // Remove Stream
    result = stm_se_encode_stream_delete(pContext->video_stream[0]);
    if (result < 0)
    {
        pr_err("Error: %s Failed to delete encode stream %d\n", __func__, result);
        goto fail_stream_delete;
    }

    // Remove the memsink
    result = stm_memsink_delete((stm_memsink_h)gVideoTest[0].Sink.obj);
    if (result < 0)
    {
        pr_err("Error: %s Failed to delete memsink\n", __func__);
        return result;
    }

    return 0;

fail_inject_discontinuity:
    VideoEncodeEventUnsubscribe(pContext);
unsubscribe_fail:
    if (stm_se_encode_stream_detach(pContext->video_stream[0], gVideoTest[0].Sink.obj)) {};
fail_stream_detach:
    if (stm_se_encode_stream_delete(pContext->video_stream[0])) {};
fail_stream_delete:
    if (stm_memsink_delete((stm_memsink_h)gVideoTest[0].Sink.obj)) {};

    return result;
}

// These tests are expected to fail ... returning success is a failure!
static int inject_fail(EncoderContext *pContext)
{
    int i = 0;
    int j = 0;
    int result = 0;
    int failures = 0;
    bpa_buffer original_raw_video_frame;
    bpa_buffer compressed_video_frame;
    stm_se_uncompressed_frame_metadata_t original_descriptor;
    stm_se_uncompressed_frame_metadata_t descriptor;
    //stm_se_picture_resolution_t Resolution;
    stm_se_framerate_t Framerate;

    pr_info("%s: Testing Failure Cases - You could expect errors here\n", __func__);

    // Allocate Memory Buffer
    result = AllocateBuffer(TEST_BUFFER_SIZE, &original_raw_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to allocate a physical buffer of size %d bytes to store the sequence (%d)\n", __func__, TEST_BUFFER_SIZE, result);
        return result;
    }

    result = AllocateBuffer(COMPRESSED_BUFFER_SIZE, &compressed_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to allocate a physical buffer of size %d bytes to store the stream (%d)\n", __func__, COMPRESSED_BUFFER_SIZE, result);
        goto allocation_fail;
    }

    memset(compressed_video_frame.virtual, 0, COMPRESSED_BUFFER_SIZE);
    gVideoTest[0].Sink.m_Buffer = (unsigned char *)compressed_video_frame.virtual;
    gVideoTest[0].Sink.m_BufferLen = compressed_video_frame.size;

    // Fill buffer
    memset(original_raw_video_frame.virtual, 0x80, original_raw_video_frame.size);
#ifdef DUMP_INPUT_BUFFER
    print_hex_dump(KERN_INFO, "INPUT BUFFER DUMP IN HEXADECIMAL: ", DUMP_PREFIX_OFFSET, 16, 1,
                   original_raw_video_frame.virtual, min((unsigned) 64, original_raw_video_frame.size), true);
#endif

    memset(&original_descriptor, 0, sizeof(descriptor));
    original_descriptor.media = STM_SE_ENCODE_STREAM_MEDIA_VIDEO;
    original_descriptor.video.frame_rate.framerate_num                        = VIDEO_FRAME_RATE_NUM;
    original_descriptor.video.frame_rate.framerate_den                        = VIDEO_FRAME_RATE_DEN;
    original_descriptor.video.video_parameters.width                          = VIDEO_WIDTH;
    original_descriptor.video.video_parameters.height                         = VIDEO_HEIGHT;
    original_descriptor.video.video_parameters.colorspace                     = (VIDEO_WIDTH > SD_WIDTH ? STM_SE_COLORSPACE_SMPTE170M : STM_SE_COLORSPACE_SMPTE240M);
    original_descriptor.video.video_parameters.aspect_ratio                   = STM_SE_ASPECT_RATIO_4_BY_3;
    original_descriptor.video.video_parameters.pixel_aspect_ratio_numerator   = 1;
    original_descriptor.video.video_parameters.pixel_aspect_ratio_denominator = 1;
    original_descriptor.video.video_parameters.scan_type                      = STM_SE_SCAN_TYPE_PROGRESSIVE;
    original_descriptor.video.pitch                                           = VIDEO_PITCH;
    original_descriptor.video.window_of_interest                              = (stm_se_picture_rectangle_t) { 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT };
    original_descriptor.video.picture_type                                    = STM_SE_PICTURE_TYPE_UNKNOWN;
    original_descriptor.video.surface_format                                  = VIDEO_SURFACE_FORMAT;
    original_descriptor.video.vertical_alignment                              = VERTICAL_ALIGNMENT;
    original_descriptor.native_time_format = TIME_FORMAT_PTS;
    original_descriptor.native_time   = 0;
    original_descriptor.system_time   = 0;
    original_descriptor.discontinuity = STM_SE_DISCONTINUITY_CONTINUOUS;

    for (i = 0 ; i < (sizeof(BAD_H264_OUTPUT_FRAMERATE) / sizeof(BAD_H264_OUTPUT_FRAMERATE[0])) ; i++)
    {
        pr_info("BAD_H264_OUTPUT_FRAMERATE[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        Framerate.framerate_num = BAD_H264_OUTPUT_FRAMERATE[i][0];
        Framerate.framerate_den = BAD_H264_OUTPUT_FRAMERATE[i][1];
        result = stm_se_encode_stream_set_compound_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_FRAMERATE, &Framerate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE * VIDEO_FRAME_RATE_DEN / VIDEO_FRAME_RATE_NUM) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }
        }

        if (gVideoTest[0].FatalErrorReceived == 0)
        {
            pr_err("Error: %s Expected failure on fatal error event\n", __func__);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(BAD_H264_LEVEL_VS_FS) / sizeof(BAD_H264_LEVEL_VS_FS[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(BAD_H264_LEVEL_VS_FS[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(BAD_H264_LEVEL_VS_FS[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(BAD_H264_LEVEL_VS_FS[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("BAD_H264_LEVEL_VS_FS[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, BAD_H264_LEVEL_VS_FS[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, BAD_H264_LEVEL_VS_FS[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = BAD_H264_LEVEL_VS_FS[i][TESTED_Width];
        descriptor.video.video_parameters.height = BAD_H264_LEVEL_VS_FS[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }
        }

        if (gVideoTest[0].FatalErrorReceived == 0)
        {
            pr_err("Error: %s Expected failure on fatal error event\n", __func__);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(BAD_H264_LEVEL_VS_BR) / sizeof(BAD_H264_LEVEL_VS_BR[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(BAD_H264_LEVEL_VS_BR[i][TESTED_Level]);
        uint32_t bitrate = LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(BAD_H264_LEVEL_VS_BR[i][TESTED_Profile]);
        uint32_t cpb_size = min(bitrate * 2, LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(BAD_H264_LEVEL_VS_BR[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("BAD_H264_LEVEL_VS_BR[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate + 1);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, BAD_H264_LEVEL_VS_BR[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, BAD_H264_LEVEL_VS_BR[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = BAD_H264_LEVEL_VS_BR[i][TESTED_Width];
        descriptor.video.video_parameters.height = BAD_H264_LEVEL_VS_BR[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }
        }

        if (gVideoTest[0].FatalErrorReceived == 0)
        {
            pr_err("Error: %s Expected failure on fatal error event\n", __func__);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(BAD_H264_LEVEL_VS_CPB) / sizeof(BAD_H264_LEVEL_VS_CPB[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(BAD_H264_LEVEL_VS_CPB[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(BAD_H264_LEVEL_VS_CPB[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(BAD_H264_LEVEL_VS_CPB[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("BAD_H264_LEVEL_VS_CPB[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size + 1);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, BAD_H264_LEVEL_VS_CPB[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, BAD_H264_LEVEL_VS_CPB[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = BAD_H264_LEVEL_VS_CPB[i][TESTED_Width];
        descriptor.video.video_parameters.height = BAD_H264_LEVEL_VS_CPB[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }
        }

        if (gVideoTest[0].FatalErrorReceived == 0)
        {
            pr_err("Error: %s Expected failure on fatal error event\n", __func__);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(BAD_H264_LEVEL_VS_MBPS) / sizeof(BAD_H264_LEVEL_VS_MBPS[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(BAD_H264_LEVEL_VS_MBPS[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(BAD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(BAD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]));
        uint32_t framerate = LevelLimits[levelIndex][LL_MaxMBPS] / LevelLimits[levelIndex][LL_MaxFS];

        pr_info("BAD_H264_LEVEL_VS_MBPS[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, BAD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, BAD_H264_LEVEL_VS_MBPS[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = BAD_H264_LEVEL_VS_MBPS[i][TESTED_Width];
        descriptor.video.video_parameters.height = BAD_H264_LEVEL_VS_MBPS[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate + 1;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / (framerate + 1)) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }
        }

        if (gVideoTest[0].FatalErrorReceived == 0)
        {
            pr_err("Error: %s Expected failure on fatal error event\n", __func__);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    // Free BPA Memory
    result = FreeBuffer(&compressed_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to free stream buffer (%d)\n", __func__, result);
    }

    gVideoTest[0].Sink.m_Buffer = NULL;
    gVideoTest[0].Sink.m_BufferLen = 0;

    result = FreeBuffer(&original_raw_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to free sequence buffer (%d)\n", __func__, result);
    }

    pr_info("%s: Failure testing complete (%d)\n", __func__, failures);
    return failures;

set_control_fail:
    if (deinit_stream(pContext)) {};
init_stream_fail:
deinit_stream_fail:
    if (FreeBuffer(&compressed_video_frame)) {};
allocation_fail:
    if (FreeBuffer(&original_raw_video_frame)) {};

    return result;
}

// These tests are expected to pass ... returning success is a good thing
static int inject_pass(EncoderContext *pContext)
{
    int i = 0;
    int j = 0;
    int failures = 0;
    int result = 0;
    bpa_buffer original_raw_video_frame;
    bpa_buffer compressed_video_frame;
    stm_se_uncompressed_frame_metadata_t original_descriptor;
    stm_se_uncompressed_frame_metadata_t descriptor;
    //stm_se_picture_resolution_t Resolution;
    stm_se_framerate_t Framerate;

    pr_info("%s: Testing Pass Cases - You should not expect errors here\n", __func__);

    // Allocate Memory Buffer
    result = AllocateBuffer(TEST_BUFFER_SIZE, &original_raw_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to allocate a physical buffer of size %d bytes to store the sequence (%d)\n", __func__, TEST_BUFFER_SIZE, result);
        return result;
    }

    result = AllocateBuffer(COMPRESSED_BUFFER_SIZE, &compressed_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to allocate a physical buffer of size %d bytes to store the stream (%d)\n", __func__, COMPRESSED_BUFFER_SIZE, result);
        goto allocation_fail;
    }

    memset(compressed_video_frame.virtual, 0, COMPRESSED_BUFFER_SIZE);
    gVideoTest[0].Sink.m_Buffer = (unsigned char *)compressed_video_frame.virtual;
    gVideoTest[0].Sink.m_BufferLen = compressed_video_frame.size;

    // Fill buffer
    memset(original_raw_video_frame.virtual, 0x80, original_raw_video_frame.size);
#ifdef DUMP_INPUT_BUFFER
    print_hex_dump(KERN_INFO, "INPUT BUFFER DUMP IN HEXADECIMAL: ", DUMP_PREFIX_OFFSET, 16, 1,
                   original_raw_video_frame.virtual, min((unsigned) 64, original_raw_video_frame.size), true);
#endif

    memset(&original_descriptor, 0, sizeof(descriptor));
    original_descriptor.media = STM_SE_ENCODE_STREAM_MEDIA_VIDEO;
    original_descriptor.video.frame_rate.framerate_num                        = VIDEO_FRAME_RATE_NUM;
    original_descriptor.video.frame_rate.framerate_den                        = VIDEO_FRAME_RATE_DEN;
    original_descriptor.video.video_parameters.width                          = VIDEO_WIDTH;
    original_descriptor.video.video_parameters.height                         = VIDEO_HEIGHT;
    original_descriptor.video.video_parameters.colorspace                     = (VIDEO_WIDTH > SD_WIDTH ? STM_SE_COLORSPACE_SMPTE170M : STM_SE_COLORSPACE_SMPTE240M);
    original_descriptor.video.video_parameters.aspect_ratio                   = STM_SE_ASPECT_RATIO_4_BY_3;
    original_descriptor.video.video_parameters.pixel_aspect_ratio_numerator   = 1;
    original_descriptor.video.video_parameters.pixel_aspect_ratio_denominator = 1;
    original_descriptor.video.video_parameters.scan_type                      = STM_SE_SCAN_TYPE_PROGRESSIVE;
    original_descriptor.video.pitch                                           = VIDEO_PITCH;
    original_descriptor.video.window_of_interest                              = (stm_se_picture_rectangle_t) { 0, 0, VIDEO_WIDTH, VIDEO_HEIGHT };
    original_descriptor.video.picture_type                                    = STM_SE_PICTURE_TYPE_UNKNOWN;
    original_descriptor.video.surface_format                                  = VIDEO_SURFACE_FORMAT;
    original_descriptor.video.vertical_alignment                              = VERTICAL_ALIGNMENT;
    original_descriptor.native_time_format = TIME_FORMAT_PTS;
    original_descriptor.native_time   = 0;
    original_descriptor.system_time   = 0;
    original_descriptor.discontinuity = STM_SE_DISCONTINUITY_CONTINUOUS;

    for (i = 0 ; i < (sizeof(GOOD_H264_OUTPUT_FRAMERATE) / sizeof(GOOD_H264_OUTPUT_FRAMERATE[0])) ; i++)
    {
        pr_info("GOOD_H264_OUTPUT_FRAMERATE[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        Framerate.framerate_num = GOOD_H264_OUTPUT_FRAMERATE[i][0];
        Framerate.framerate_den = GOOD_H264_OUTPUT_FRAMERATE[i][1];
        result = stm_se_encode_stream_set_compound_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_FRAMERATE, &Framerate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE * VIDEO_FRAME_RATE_DEN / VIDEO_FRAME_RATE_NUM) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }

            do
            {
                pr_info("Pull data\n");
            }
            while (PullCompressedEncode(&gVideoTest[0].Sink) == 0);
        }

        if (gVideoTest[0].FatalErrorReceived > 0)
        {
            pr_err("Error: %s Expected pass on fatal error event, FatalErrorReceived = %u\n", __func__, gVideoTest[0].FatalErrorReceived);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(GOOD_H264_LEVEL_VS_FS) / sizeof(GOOD_H264_LEVEL_VS_FS[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(GOOD_H264_LEVEL_VS_FS[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_FS[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_FS[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("GOOD_H264_LEVEL_VS_FS[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, GOOD_H264_LEVEL_VS_FS[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, GOOD_H264_LEVEL_VS_FS[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = GOOD_H264_LEVEL_VS_FS[i][TESTED_Width];
        descriptor.video.video_parameters.height = GOOD_H264_LEVEL_VS_FS[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }

            do
            {
                pr_info("Pull data\n");
            }
            while (PullCompressedEncode(&gVideoTest[0].Sink) == 0);
        }

        if (gVideoTest[0].FatalErrorReceived > 0)
        {
            pr_err("Error: %s Expected pass on fatal error event, FatalErrorReceived = %u\n", __func__, gVideoTest[0].FatalErrorReceived);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(GOOD_H264_LEVEL_VS_BR) / sizeof(GOOD_H264_LEVEL_VS_BR[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(GOOD_H264_LEVEL_VS_BR[i][TESTED_Level]);
        uint32_t bitrate = LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_BR[i][TESTED_Profile]);
        uint32_t cpb_size = min(bitrate * 2, LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_BR[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("GOOD_H264_LEVEL_VS_BR[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, GOOD_H264_LEVEL_VS_BR[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, GOOD_H264_LEVEL_VS_BR[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = GOOD_H264_LEVEL_VS_BR[i][TESTED_Width];
        descriptor.video.video_parameters.height = GOOD_H264_LEVEL_VS_BR[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }

            do
            {
                pr_info("Pull data\n");
            }
            while (PullCompressedEncode(&gVideoTest[0].Sink) == 0);
        }

        if (gVideoTest[0].FatalErrorReceived > 0)
        {
            pr_err("Error: %s Expected pass on fatal error event, FatalErrorReceived = %u\n", __func__, gVideoTest[0].FatalErrorReceived);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(GOOD_H264_LEVEL_VS_CPB) / sizeof(GOOD_H264_LEVEL_VS_CPB[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(GOOD_H264_LEVEL_VS_CPB[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_CPB[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_CPB[i][TESTED_Profile]));
        uint32_t framerate = 5;

        pr_info("GOOD_H264_LEVEL_VS_CPB[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, GOOD_H264_LEVEL_VS_CPB[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, GOOD_H264_LEVEL_VS_CPB[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = GOOD_H264_LEVEL_VS_CPB[i][TESTED_Width];
        descriptor.video.video_parameters.height = GOOD_H264_LEVEL_VS_CPB[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }

            do
            {
                pr_info("Pull data\n");
            }
            while (PullCompressedEncode(&gVideoTest[0].Sink) == 0);
        }

        if (gVideoTest[0].FatalErrorReceived > 0)
        {
            pr_err("Error: %s Expected pass on fatal error event, FatalErrorReceived = %u\n", __func__, gVideoTest[0].FatalErrorReceived);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    for (i = 0 ; i < (sizeof(GOOD_H264_LEVEL_VS_MBPS) / sizeof(GOOD_H264_LEVEL_VS_MBPS[0])) ; i++)
    {
        uint32_t levelIndex = GetLevelIndex(GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Level]);
        uint32_t cpb_size = LevelLimits[levelIndex][LL_MaxCPB] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]);
        uint32_t bitrate = min(cpb_size / 2, LevelLimits[levelIndex][LL_MaxBR] * GetCpbNalFactor(GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]));
        uint32_t framerate = LevelLimits[levelIndex][LL_MaxMBPS] / LevelLimits[levelIndex][LL_MaxFS];

        pr_info("GOOD_H264_LEVEL_VS_MBPS[%d]\n", i);
        result = init_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on init_stream\n", __func__);
            goto init_stream_fail;
        }

        // STM_SE_CTRL_ENCODE_STREAM_BITRATE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_ENCODE_STREAM_BITRATE, bitrate);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        // STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE Control
        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_CPB_SIZE, cpb_size);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_PROFILE, GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Profile]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        result = stm_se_encode_stream_set_control(pContext->video_stream[0], STM_SE_CTRL_VIDEO_ENCODE_STREAM_H264_LEVEL, GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Level]);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on testing set valid control\n", __func__);
            goto set_control_fail;
        }

        descriptor = original_descriptor;
        descriptor.video.video_parameters.width = GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Width];
        descriptor.video.video_parameters.height = GOOD_H264_LEVEL_VS_MBPS[i][TESTED_Height];
        descriptor.video.pitch = descriptor.video.video_parameters.width;
        descriptor.video.video_parameters.aspect_ratio = STM_SE_ASPECT_RATIO_UNSPECIFIED;
        descriptor.video.frame_rate.framerate_num = framerate;
        descriptor.video.frame_rate.framerate_den = 1;

        for (j = 0 ; j < INJECT_COUNT ; j++)
        {
            descriptor.native_time = (PTS_TIME_SCALE / framerate) * j;
            descriptor.system_time = jiffies;
            result = stm_se_encode_stream_inject_frame(pContext->video_stream[0], original_raw_video_frame.virtual, original_raw_video_frame.physical, original_raw_video_frame.size, descriptor);
            if (result < 0)
            {
                pr_err("Error: %s Expected pass on testing valid inject frame\n", __func__);
                goto set_control_fail;
            }

            do
            {
                pr_info("Pull data\n");
            }
            while (PullCompressedEncode(&gVideoTest[0].Sink) == 0);
        }

        if (gVideoTest[0].FatalErrorReceived > 0)
        {
            pr_err("Error: %s Expected pass on fatal error event, FatalErrorReceived = %u\n", __func__, gVideoTest[0].FatalErrorReceived);
            failures++;
        }

        gVideoTest[0].FatalErrorReceived = 0;

        result = deinit_stream(pContext);
        if (result < 0)
        {
            pr_err("Error: %s Expected pass on deinit_stream\n", __func__);
            goto deinit_stream_fail;
        }
    }

    // Free BPA Memory
    result = FreeBuffer(&compressed_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to free stream buffer (%d)\n", __func__, result);
    }

    gVideoTest[0].Sink.m_Buffer = NULL;
    gVideoTest[0].Sink.m_BufferLen = 0;

    result = FreeBuffer(&original_raw_video_frame);
    if (result < 0)
    {
        pr_err("Error: %s Failed to free sequence buffer (%d)\n", __func__, result);
    }

    pr_info("%s: Pass testing complete (%d)\n", __func__, failures);
    return failures;

set_control_fail:
    if (deinit_stream(pContext)) {};
init_stream_fail:
deinit_stream_fail:
    if (FreeBuffer(&compressed_video_frame)) {};
allocation_fail:
    if (FreeBuffer(&original_raw_video_frame)) {};

    return result;
}

static int video_inject_frame_h264(EncoderTestArg *arg)
{
    EncoderContext context = {0};
    EncoderContext *pContext = &context;

    int result = 0;
    int failures = 0;

    memset(&gVideoTest, 0, sizeof(gVideoTest));

    // Create an Encode Object
    result = stm_se_encode_new("Encode0", &pContext->encode);
    if (result < 0)
    {
        pr_err("Error: %s Failed to create a new Encode\n", __func__);
        return result;
    }

    // Perform control and metadata testing
    result = inject_fail(pContext);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on inject_fail\n", __func__);
        goto inject_fail;
    }
    failures += result;

    result = inject_pass(pContext);
    if (result < 0)
    {
        pr_err("Error: %s Expected pass on inject_pass\n", __func__);
        goto inject_fail;
    }
    failures += result;

    result = stm_se_encode_delete(pContext->encode);
    if (result < 0)
    {
        pr_err("Error: %s stm_se_encode_delete returned %d\n", __func__, result);
        return result;
    }

    return failures;

inject_fail:
    if (stm_se_encode_delete(pContext->encode)) {};

    return result;
}

/*** Only 40 Chars will be displayed ***/
ENCODER_TEST(video_inject_frame_h264, "Test Inject Frame H264", BASIC_TEST);
