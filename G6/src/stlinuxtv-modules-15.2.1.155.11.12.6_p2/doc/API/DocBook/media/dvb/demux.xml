<title>DVB Demux Device</title>

<para>The DVB demux device controls the filters of the DVB hardware/software. It can be
accessed through <emphasis role="tt">/dev/adapter0/demux0</emphasis>. Data types and and ioctl definitions can be
accessed by including <emphasis role="tt">linux/dvb/dmx.h</emphasis> in your application.
</para>
<section id="dmx_types">
<title>Demux Data Types</title>

<section id="dmx-output-t">
<title>dmx_output_t</title>
<programlisting>
typedef enum
{
	DMX_OUT_DECODER, /&#x22C6; Streaming directly to decoder. &#x22C6;/
	DMX_OUT_TAP,     /&#x22C6; Output going to a memory buffer &#x22C6;/
			 /&#x22C6; (to be retrieved via the read command).&#x22C6;/
	DMX_OUT_TS_TAP,  /&#x22C6; Output multiplexed into a new TS  &#x22C6;/
			 /&#x22C6; (to be retrieved by reading from the &#x22C6;/
			 /&#x22C6; logical DVR device).                 &#x22C6;/
	DMX_OUT_TSDEMUX_TAP /&#x22C6; Like TS_TAP but retrieved from the DMX device &#x22C6;/
} dmx_output_t;
</programlisting>
<para><emphasis role="tt">DMX_OUT_TAP</emphasis> delivers the stream output to the demux device on which the ioctl is
called.
</para>
<para><emphasis role="tt">DMX_OUT_TS_TAP</emphasis> routes output to the logical DVR device <emphasis role="tt">/dev/dvb/adapter0/dvr0</emphasis>,
which delivers a TS multiplexed from all filters for which <emphasis role="tt">DMX_OUT_TS_TAP</emphasis> was
specified.
</para>
</section>

<section id="dmx-input-t">
<title>dmx_input_t</title>
<programlisting>
typedef enum
{
	DMX_IN_FRONTEND, /&#x22C6; Input from a front-end device.  &#x22C6;/
	DMX_IN_DVR       /&#x22C6; Input from the logical DVR device.  &#x22C6;/
} dmx_input_t;
</programlisting>
</section>

<section id="dmx-pes-type-t">
<title>dmx_pes_type_t</title>
<programlisting>
typedef enum
{
	DMX_PES_AUDIO0,
	DMX_PES_VIDEO0,
	DMX_PES_TELETEXT0,
	DMX_PES_SUBTITLE0,
	DMX_PES_PCR0,

	DMX_PES_AUDIO1,
	DMX_PES_VIDEO1,
	DMX_PES_TELETEXT1,
	DMX_PES_SUBTITLE1,
	DMX_PES_PCR1,

	DMX_PES_AUDIO2,
	DMX_PES_VIDEO2,
	DMX_PES_TELETEXT2,
	DMX_PES_SUBTITLE2,
	DMX_PES_PCR2,

	DMX_PES_AUDIO3,
	DMX_PES_VIDEO3,
	DMX_PES_TELETEXT3,
	DMX_PES_SUBTITLE3,
	DMX_PES_PCR3,

	DMX_PES_OTHER
} dmx_pes_type_t;
</programlisting>
</section>

<section id="dmx-filter">
<title>struct dmx_filter</title>
 <programlisting>
 typedef struct dmx_filter
{
	__u8  filter[DMX_FILTER_SIZE];
	__u8  mask[DMX_FILTER_SIZE];
	__u8  mode[DMX_FILTER_SIZE];
} dmx_filter_t;
</programlisting>
</section>

<section id="dmx-sct-filter-params">
<title>struct dmx_sct_filter_params</title>
<programlisting>
struct dmx_sct_filter_params
{
	__u16          pid;
	dmx_filter_t   filter;
	__u32          timeout;
	__u32          flags;
#define DMX_CHECK_CRC       1
#define DMX_ONESHOT         2
#define DMX_IMMEDIATE_START 4
#define DMX_KERNEL_CLIENT   0x8000
};
</programlisting>
</section>

<section id="dmx-pes-filter-params">
<title>struct dmx_pes_filter_params</title>
<programlisting>
struct dmx_pes_filter_params
{
	__u16          pid;
	dmx_input_t    input;
	dmx_output_t   output;
	dmx_pes_type_t pes_type;
	__u32          flags;
#define DMX_TS_NO_FLUSH_ON_DETACH 0x8
};
</programlisting>
<para>[STMicroelectronics]The input field is not taken into account (see DMX_SET_SOURCE for information about how to select the demux source)</para>
</section>

<section id="dmx-event">
<title>struct dmx_event</title>
 <programlisting>
 struct dmx_event
 {
	 dmx_event_t          event;
	 time_t               timeStamp;
	 union
	 {
		 dmx_scrambling_status_t scrambling;
	 } u;
 };
</programlisting>
</section>

<section id="dmx-stc">
<title>struct dmx_stc</title>
<programlisting>
struct dmx_stc {
	unsigned int num;	/&#x22C6; input : which STC? 0..N &#x22C6;/
	unsigned int base;	/&#x22C6; output: divisor for stc to get 90 kHz clock &#x22C6;/
	__u64 stc;		/&#x22C6; output: stc in 'base'&#x22C6;90 kHz units &#x22C6;/
};
</programlisting>
</section>

<section id="dmx-caps">
<title>struct dmx_caps</title>
<programlisting>
 typedef struct dmx_caps {
	__u32 caps;
	int num_decoders;
} dmx_caps_t;
</programlisting>
</section>

<section id="dmx-source-t">
<title>enum dmx_source_t</title>
<programlisting>
typedef enum {
	DMX_SOURCE_FRONT0 = 0,
	DMX_SOURCE_FRONT1,
	DMX_SOURCE_FRONT2,
	DMX_SOURCE_FRONT3,
	DMX_SOURCE_DVR0   = 16,
	DMX_SOURCE_DVR1,
	DMX_SOURCE_DVR2,
	DMX_SOURCE_DVR3
} dmx_source_t;
</programlisting>
</section>

<section id="dmx-pcr">
<title>struct dmx_pcr [STMicroelectronics extension]</title>
<programlisting>
struct dmx_pcr
{
	unsigned long long  pcr;            // Returned in pts format
	unsigned long long  system_time;
};</programlisting>
<para>The structure describes formatted data read from the demux device after that demux has
been configured to read PCR data (by setting the pes_type to DMX_PES_PCR. It contains 
a PCR received from the source and its arrival timestamp as a
local system time.</para>
</section>

<section id="dmx-index-event">
<title>enum dmx_index_event [STMicroelectronics extension]</title>
<programlisting>
typedef  enum {
	DMX_INDEX_NONE             = 0x0000, /* No event */
	DMX_INDEX_PUSI             = 0x0001, /* Payload Unit Start Indicator Flag */
	DMX_INDEX_SCRAM_TO_CLEAR   = 0x0002, /* Scrambling Change To Clear Flag */
	DMX_INDEX_TO_EVEN_SCRAM    = 0x0004, /* Scrambling Change to Even Flag */
	DMX_INDEX_TO_ODD_SCRAM     = 0x0008, /* Scrambling Change To Odd Flag */
	DMX_INDEX_DISCONTINUITY    = 0x0010, /* Discontinuity Flag */
	DMX_INDEX_RANDOM_ACCESS    = 0x0020, /* Random Access Flag */
	DMX_INDEX_ES_PRIORITY      = 0x0040, /* ES Priority Flag */
	DMX_INDEX_PCR              = 0x0080, /* PCR Flag */
	DMX_INDEX_OPCR             = 0x0100, /* OPCR Flag */
	DMX_INDEX_SPLICING_POINT   = 0x0200, /* Splicing Point Flag */
	DMX_INDEX_TS_PRIVATE_DATA  = 0x0400, /* Transport Private Data Flag */
	DMX_INDEX_ADAPTATION_EXT   = 0x0800, /* Adaptation Field Extension Flag */
	DMX_INDEX_FIRST_REC_PACKET = 0x1000, /* First Recorded Packet */
	DMX_INDEX_START_CODE       = 0x2000,  /* Index Start Code Flag */
	DMX_INDEX_PTS              = 0x4000   /* PTS Flag */
} dmx_index_event;
</programlisting>
<para>Enumeration of type of events, used within the struct dmx_index. <xref linkend="dmx-index"/>
</para>
</section>

<section id="dmx-index">
<title>struct dmx_index [STMicroelectronics extension]</title>
<programlisting>
typedef struct dmx_index {
	__u16 pid;
	dmx_index_event event;
	unsigned int packet_count;
	unsigned long long pcr;
	unsigned long long system_time;
	unsigned char mpeg_start_code;
	unsigned char mpeg_start_code_offset;
	__u16 extra_bytes;
	unsigned char extra[5];
};</programlisting>
<para>The structure describes formatted data read from the demux device after that demux has
been configured to read INDEX data via the DMX_SET_INDEX_FILTER ioctl.
</para>
</section>

<section id="dmx-index-pid">
<title>struct dmx_index_pid  [STMicroelectronics extension]</title>
<programlisting>
struct dmx_index_pid {
	__u16 pid;
	__u8 number_of_start_codes;
	__u8 *start_codes;
	dmx_index_event flags;
};</programlisting>
<para>Structure used within struct dmx_index_filter_params <xref linkend="dmx-index-filter-params"/> and describe from which pid to get what kind of events from</para>
</section>

<section id="dmx-index-filter-params">
<title>struct dmx_index_filter_params [STMicroelectronics extension]</title>
<programlisting>
struct dmx_index_filter_params 
{
	unsigned int n_pids;
	struct dmx_index_pid *pids;
};</programlisting>
<para>Structure used by the ioctl DMX_SET_INDEX_FILTER to register index filters</para>
</section>

<section id="dmx-insert-filter-params">
<title>struct dmx_insert_filter_params [STMicroelectronics extension]</title>
<programlisting>
struct dmx_insert_filter_params 
{
	unsigned int pids;
	unsigned int freq_ms;
	unsigned char * data;
	unsigned int data_size;
};</programlisting>
<para>Structure used by the ioctl DMX_SET_INS_FILTER to insert a new PID within a generated TS stream.</para>
</section>

<section id="dmx-replace-filter-params">
<title>struct dmx_replace_filter_params [STMicroelectronics extension]</title>
<programlisting>
struct dmx_replace_filter_params 
{
	unsigned int pids;
	unsigned char * data;
	unsigned int data_size;
};</programlisting>
<para>Structure used by the ioctl DMX_SET_REP_FILTER to insert an existing PID within a TS with new new data.</para>
</section>

<section id="dmx-ts-format-t">
<title>dmx_ts_format_t [STMicroelectronics extension]</title>
<programlisting>
typedef enum {
        DMX_TS_AUTO                     = 0x0000, /* Auto-detected by demux */
        DMX_TS_TYPE_DVB                 = 0x0001, /* DVB type, 188 bytes MPEG TS packet */
        DMX_TS_TYPE_TTS                 = 0x0002  /* 192 bytes TTS (time stamped transport stream) */
} dmx_ts_format_t;
</programlisting>
<para>Enum used by the ioctl DMX_SET_TS_FORMAT to specify the format of TS data to be handled by the DVR device</para>
</section>

<section id="dmx-scrambling-t">
<title>dmx_scrambling_t [STMicroelectronics extension]</title>
<programlisting>
typedef enum {
        DMX_SCRAMBLED,  /* Non descrambled data generated */
        DMX_DESCRAMBLED /* Descrambled data generated */
} dmx_scrambling_t;
</programlisting>
<para>Enum used by the ioctl DMX_SET_SCRAMBLING to specify if data exported via the DVR device should be descrambled or not.</para>
</section>
</section>

<section id="dmx_fcalls">
<title>Demux Function Calls</title>

<section id="dmx_fopen">
<title>open()</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This system call, used with a device name of /dev/dvb/adapter0/demux0,
 allocates a new filter and returns a handle which can be used for subsequent
 control of that filter. This call has to be made for each filter to be used, i.e. every
 returned file descriptor is a reference to a single filter. /dev/dvb/adapter0/dvr0
 is a logical device to be used for retrieving Transport Streams for digital
 video recording. When reading from this device a transport stream containing
 the packets from all PES filters set in the corresponding demux device
 (/dev/dvb/adapter0/demux0) having the output set to DMX_OUT_TS_TAP. A
 recorded Transport Stream is replayed by writing to this device. </para>
<para>The significance of blocking or non-blocking mode is described in the
 documentation for functions where there is a difference. It does not affect the
 semantics of the open() call itself. A device opened in blocking mode can later
 be put into non-blocking mode (and vice versa) using the F_SETFL command
 of the fcntl system call.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int open(const char &#x22C6;deviceName, int flags);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>const char
 *deviceName</para>
</entry><entry
 align="char">
<para>Name of demux device.</para>
</entry>
 </row><row><entry
 align="char">
<para>int flags</para>
</entry><entry
 align="char">
<para>A bit-wise OR of the following flags:</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>O_RDWR read/write access</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>O_NONBLOCK open in non-blocking mode</para>
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>(blocking mode is the default)</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>ENODEV</para>
</entry><entry
 align="char">
<para>Device driver not loaded/available.</para>
</entry>
 </row><row><entry
 align="char">
<para>EINVAL</para>
</entry><entry
 align="char">
<para>Invalid argument.</para>
</entry>
 </row><row><entry
 align="char">
<para>EMFILE</para>
</entry><entry
 align="char">
<para>&#8220;Too many open files&#8221;, i.e. no more filters available.</para>
</entry>
 </row><row><entry
 align="char">
<para>ENOMEM</para>
</entry><entry
 align="char">
<para>The driver failed to allocate enough memory.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="dmx_fclose">
<title>close()</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This system call deactivates and deallocates a filter that was previously
 allocated via the open() call.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int close(int fd);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EBADF</para>
</entry><entry
 align="char">
<para>fd is not a valid open file descriptor.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="dmx_fread">
<title>read()</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This system call returns filtered data, which might be section or PES data. The
 filtered data is transferred from the driver&#8217;s internal circular buffer to buf. The
 maximum amount of data to be transferred is implied by count.</para>
</entry>
 </row><row><entry
 align="char">
<para>When returning section data the driver always tries to return a complete single
 section (even though buf would provide buffer space for more data). If the size
 of the buffer is smaller than the section as much as possible will be returned,
 and the remaining data will be provided in subsequent calls.</para>
</entry>
 </row><row><entry
 align="char">
<para>The size of the internal buffer is 2 * 4096 bytes (the size of two maximum
 sized sections) by default. The size of this buffer may be changed by using the
 DMX_SET_BUFFER_SIZE function. If the buffer is not large enough, or if
 the read operations are not performed fast enough, this may result in a buffer
 overflow error. In this case EOVERFLOW will be returned, and the circular
 buffer will be emptied. This call is blocking if there is no data to return, i.e. the
 process will be put to sleep waiting for data, unless the O_NONBLOCK flag
 is specified.</para>
</entry>
 </row><row><entry
 align="char">
<para>Note that in order to be able to read, the filtering process has to be started
 by defining either a section or a PES filter by means of the ioctl functions,
 and then starting the filtering process via the DMX_START ioctl function
 or by setting the DMX_IMMEDIATE_START flag. If the reading is done
 from a logical DVR demux device, the data will constitute a Transport Stream
 including the packets from all PES filters in the corresponding demux device
 /dev/dvb/adapter0/demux0 having the output set to DMX_OUT_TS_TAP.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>size_t read(int fd, void &#x22C6;buf, size_t count);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>void *buf</para>
</entry><entry
 align="char">
<para>Pointer to the buffer to be used for returned filtered data.</para>
</entry>
 </row><row><entry
 align="char">
<para>size_t count</para>
</entry><entry
 align="char">
<para>Size of buf.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EWOULDBLOCK</para>
</entry><entry
 align="char">
<para>No data to return and O_NONBLOCK was specified.</para>
</entry>
 </row><row><entry
 align="char">
<para>EBADF</para>
</entry><entry
 align="char">
<para>fd is not a valid open file descriptor.</para>
</entry>
 </row><row><entry
 align="char">
<para>ECRC</para>
</entry><entry
 align="char">
<para>Last section had a CRC error - no data returned. The
 buffer is flushed.</para>
</entry>
 </row><row><entry
 align="char">
<para>EOVERFLOW</para>
</entry><entry
 align="char">
</entry>
 </row><row><entry
 align="char">
</entry><entry
 align="char">
<para>The filtered data was not read from the buffer in due
 time, resulting in non-read data being lost.</para>
</entry>
 </row><row><entry
 align="char">
<para>ETIMEDOUT</para>
</entry><entry
 align="char">
<para>The section was not loaded within the stated timeout
 period. See ioctl DMX_SET_FILTER for how to set a
 timeout.</para>
</entry>
 </row><row><entry
 align="char">
<para>EFAULT</para>
</entry><entry
 align="char">
<para>The driver failed to write to the callers buffer due to an
 invalid *buf pointer.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="dmx_fwrite">
<title>write()</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This system call is only provided by the logical device /dev/dvb/adapter0/dvr0,
 associated with the physical demux device that provides the actual DVR
 functionality. It is used for replay of a digitally recorded Transport Stream.
 Matching filters have to be defined in the corresponding physical demux
 device, /dev/dvb/adapter0/demux0. The amount of data to be transferred is
 implied by count.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>ssize_t write(int fd, const void &#x22C6;buf, size_t
 count);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>void *buf</para>
</entry><entry
 align="char">
<para>Pointer to the buffer containing the Transport Stream.</para>
</entry>
 </row><row><entry
 align="char">
<para>size_t count</para>
</entry><entry
 align="char">
<para>Size of buf.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>RETURN VALUE</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EWOULDBLOCK</para>
</entry><entry
 align="char">
<para>No data was written. This
 might happen if O_NONBLOCK was specified and there
 is no more buffer space available (if O_NONBLOCK is
 not specified the function will block until buffer space is
 available).</para>
</entry>
 </row><row><entry
 align="char">
<para>EBUSY</para>
</entry><entry
 align="char">
<para>This error code indicates that there are conflicting
 requests. The corresponding demux device is setup to
 receive data from the front- end. Make sure that these
 filters are stopped and that the filters with input set to
 DMX_IN_DVR are started.</para>
</entry>
 </row><row><entry
 align="char">
<para>EBADF</para>
</entry><entry
 align="char">
<para>fd is not a valid open file descriptor.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="DMX_START">
<title>DMX_START</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to start the actual filtering operation defined via the ioctl
 calls DMX_SET_FILTER or DMX_SET_PES_FILTER.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_START);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_START for this command.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EINVAL</para>
</entry><entry
 align="char">
<para>Invalid argument, i.e. no filtering parameters provided via
 the DMX_SET_FILTER or DMX_SET_PES_FILTER
 functions.</para>
</entry>
 </row><row><entry
 align="char">
<para>EBUSY</para>
</entry><entry
 align="char">
<para>This error code indicates that there are conflicting
 requests. There are active filters filtering data from
 another input source. Make sure that these filters are
 stopped before starting this filter.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="DMX_STOP">
<title>DMX_STOP</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to stop the actual filtering operation defined via the
 ioctl calls DMX_SET_FILTER or DMX_SET_PES_FILTER and started via
 the DMX_START command.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_STOP);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_STOP for this command.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="DMX_FLUSH_CHANNEL">
<title>DMX_FLUSH_CHANNEL</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to flush the filtered data held by Transport Engine
 in an intermiediate buffer.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_FLUSH_CHANNEL);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_FLUSH_CHANNEL for this command.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="DMX_SET_FILTER">
<title>DMX_SET_FILTER</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call sets up a filter according to the filter and mask parameters
 provided. A timeout may be defined stating number of seconds to wait for a
 section to be loaded. A value of 0 means that no timeout should be applied.
 Finally there is a flag field where it is possible to state whether a section should
 be CRC-checked, whether the filter should be a &#8221;one-shot&#8221; filter, i.e. if the
 filtering operation should be stopped after the first section is received, and
 whether the filtering operation should be started immediately (without waiting
 for a DMX_START ioctl call). If a filter was previously set-up, this filter will
 be canceled, and the receive buffer will be flushed.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_SET_FILTER,
 struct dmx_sct_filter_params &#x22C6;params);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_SET_FILTER for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct
 dmx_sct_filter_params
 *params</para>
</entry><entry
 align="char">
<para>Pointer to structure containing filter parameters.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="DMX_SET_PES_FILTER">
<title>DMX_SET_PES_FILTER</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call sets up a PES filter according to the parameters provided. By a
 PES filter is meant a filter that is based just on the packet identifier (PID), i.e.
 no PES header or payload filtering capability is supported.</para>
</entry>
 </row><row><entry
 align="char">
<para>The transport stream destination for the filtered output may be set. Also the
 PES type may be stated in order to be able to e.g. direct a video stream directly
 to the video decoder. Finally there is a flag field where it is possible to state
 whether the filtering operation should be started immediately (without waiting
 for a DMX_START ioctl call). If a filter was previously set-up, this filter will
 be cancelled, and the receive buffer will be flushed. When we disconnect one of the
 PES filters associated with the TS read, then the default flushing behavior can be
 overridden by the flag DMX_TS_NO_FLUSH_ON_DETACH. This will not flush demux filters
 when one of the PID filters is detached. This flag is only applicable for TS buffer.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_SET_PES_FILTER,
 struct dmx_pes_filter_params &#x22C6;params);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_SET_PES_FILTER for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct
 dmx_pes_filter_params
 *params</para>
</entry><entry
 align="char">
<para>Pointer to structure containing filter parameters.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EBUSY</para>
</entry><entry
 align="char">
<para>This error code indicates that there are conflicting
 requests. There are active filters filtering data from
 another input source. Make sure that these filters are
 stopped before starting this filter.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="DMX_SET_BUFFER_SIZE">
<title>DMX_SET_BUFFER_SIZE</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call is used to set the size of the circular buffer used for filtered data.
 The default size is two maximum sized sections, i.e. if this function is not called
 a buffer size of 2 * 4096 bytes will be used.</para>
<para>[STMicroelectronics] The buffer size is maintained by transport engine based on the filter type. This ioctl allows to change the buffer size.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request =
 DMX_SET_BUFFER_SIZE, unsigned long size);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_SET_BUFFER_SIZE for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>unsigned long size</para>
</entry><entry
 align="char">
<para>Size of circular buffer.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
</section>

<section id="DMX_GET_EVENT">
<title>DMX_GET_EVENT (NOT SUPPORTED)</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call returns an event if available. If an event is not available,
 the behavior depends on whether the device is in blocking or non-blocking
 mode. In the latter case, the call fails immediately with errno set to
 EWOULDBLOCK. In the former case, the call blocks until an event becomes
 available.</para>
</entry>
 </row><row><entry
 align="char">
<para>The standard Linux poll() and/or select() system calls can be used with the
 device file descriptor to watch for new events. For select(), the file descriptor
 should be included in the exceptfds argument, and for poll(), POLLPRI should
 be specified as the wake-up condition. Only the latest event for each filter is
 saved.</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_GET_EVENT,
 struct dmx_event &#x22C6;ev);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_GET_EVENT for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct dmx_event *ev</para>
</entry><entry
 align="char">
<para>Pointer to the location where the event is to be stored.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EWOULDBLOCK</para>
</entry><entry
 align="char">
<para>There is no event pending, and the device is in
 non-blocking mode.</para>
</entry>
 </row></tbody></tgroup></informaltable>
</section>

<section id="DMX_GET_STC">
<title>DMX_GET_STC (NOT SUPPORTED)</title>
<para>DESCRIPTION
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>This ioctl call returns the current value of the system time counter (which is driven
 by a PES filter of type DMX_PES_PCR). Some hardware supports more than one
 STC, so you must specify which one by setting the num field of stc before the ioctl
 (range 0...n). The result is returned in form of a ratio with a 64 bit numerator
 and a 32 bit denominator, so the real 90kHz STC value is stc-&#x003E;stc /
 stc-&#x003E;base
 .</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>SYNOPSIS
</para>
<informaltable><tgroup cols="1"><tbody><row><entry
 align="char">
<para>int ioctl( int fd, int request = DMX_GET_STC, struct
 dmx_stc &#x22C6;stc);</para>
</entry>
 </row></tbody></tgroup></informaltable>
<para>PARAMETERS
</para>
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>int fd</para>
</entry><entry
 align="char">
<para>File descriptor returned by a previous call to open().</para>
</entry>
 </row><row><entry
 align="char">
<para>int request</para>
</entry><entry
 align="char">
<para>Equals DMX_GET_STC for this command.</para>
</entry>
 </row><row><entry
 align="char">
<para>struct dmx_stc *stc</para>
</entry><entry
 align="char">
<para>Pointer to the location where the stc is to be stored.</para>
</entry>
 </row></tbody></tgroup></informaltable>
&return-value-dvb;
<informaltable><tgroup cols="2"><tbody><row><entry
 align="char">
<para>EINVAL</para>
</entry><entry
 align="char">
<para>Invalid stc number.</para>
</entry>
 </row></tbody></tgroup></informaltable>
 </section>


<section id="DMX-SET-SOURCE" role="subsection">

<title>DMX_SET_SOURCE</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl selects the source of the demux. It can select between the four front-end options or one of the four DVR options.</para>
          <para>[STMicroelectronics] On DMX_SOURCE_FRONTEND settings are supported. The ioctl must be called PRIOR to starting the demuxing on this whole demux device (not the specific file handle). This setting is overrighten by the opening/closing of the dvr device corresponding to the demux. When the dvr device is open, the source of the demux automatically becomes the DVR device, until the dvr device get closed </para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_SOURCE, dmx_source_t *type);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open().</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_SOURCE for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>dmx_source_t *</para>
        </entry>
        <entry align="char">
          <para>Pointer to the source number, see <xref linkend="dmx-source-t"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>


<section id="DMX-SET-INDEX-FILTER" role="subsection">
<title>DMX_SET_INDEX_FILTER [STMicroelectronics extension]</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl allows to configure and start a filter for retrieving index information from the current input of the demux. In a similar way to DMX_SET_PES_FILTER with output = DMX_OUT_TAP, formatted index information will then be available from the demux device via a read call</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_INDEX_FILTER, struct dmx_index_filter_params *params);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open().</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_INDEX_FILTER for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>struct dmx_index_filter_params *params</para>
        </entry>
        <entry align="char">
          <para>Pointer to the index parameters structure that define the requested content for indexes. see <xref linkend="dmx-index-filter-params"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>

<section id="DMX-SET-INS-FILTER" role="subsection">
<title>DMX_SET_INS_FILTER [STMicroelectronics extension]</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl allows to configure and start an insertion filter that allows to insert additional pids into a TS generated by the demux. The generated TS stream is available by reading from the dvr device associated to the demux</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_INS_FILTER, struct dmx_insert_filter_params *params);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open().</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_INS_FILTER for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>struct dmx_insert_filter_params *params</para>
        </entry>
        <entry align="char">
          <para>Pointer to the insert parameters structure that define the content to be inserted into the stream. see <xref linkend="dmx-insert-filter-params"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>


<section id="DMX-SET-REP-FILTER" role="subsection">
<title>DMX_SET_REP_FILTER [STMicroelectronics extension]</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl allows to configure and start a replacement filter that allows to replace an existing pid from a stream with data provided via this ioctl. The generated TS stream is available by reading from the dvr device associated to the demux</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_REP_FILTER, struct dmx_replace_filter_params *params);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open().</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_REP_FILTER for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>struct dmx_insert_filter_params *params</para>
        </entry>
        <entry align="char">
          <para>Pointer to the replace parameters structure that define the pid to be replaced and replacement data. see <xref linkend="dmx-replace-filter-params"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>

<section id="DMX-SET-TS-FORMAT" role="subsection">
<title>DMX_SET_TS_FORMAT [STMicroelectronics extension]</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl, set on the DVR device allows to specify the format of TS data that are written or read. It can be applied on both writer dvr (injection into demux) or reader dvr (read output of demux). In case of setting of the generated TS data out of the demux (reader dvr), this ioctl must be call AFTER a DMX_SET_PES_FILTER has been called on the demux device.</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_TS_FORMAT, dmx_ts_format_t *format);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open() on the dvr device.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_TS_FORMAT for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>dmx_ts_format_t *format</para>
        </entry>
        <entry align="char">
          <para>Pointer to the format description. see <xref linkend="dmx-ts-format-t"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>

<section id="DMX-SET-SCRAMBLING" role="subsection">
<title>DMX_SET_SCRAMBLING [STMicroelectronics extension]</title>
<para>DESCRIPTION</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>This ioctl, set on the DVR device allows to specify if data read out of the dvr device at the output of the demux should contain scrambled or descrambled data.</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>SYNOPSIS</para>

<informaltable>
  <tgroup cols="1">
    <tbody>
      <row>
        <entry align="char">
          <para>int ioctl(int fd, int request = DMX_SET_SCRAMBLING, dmx_scrambling_t *scrambling);</para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>

<para>PARAMETERS</para>

<informaltable>
  <tgroup cols="2">
    <tbody>
      <row>
        <entry align="char">
          <para>int fd</para>
        </entry>
        <entry align="char">
          <para>File descriptor returned by a previous call to open() on the dvr device.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>int request</para>
        </entry>
        <entry align="char">
          <para>Equals DMX_SET_SCRAMBLING for this command.</para>
        </entry>
      </row>
      <row>
        <entry align="char">
          <para>dmx_scrambling_t *scrambling</para>
        </entry>
        <entry align="char">
          <para>Pointer to the scrambling setting. see <xref linkend="dmx-scrambling-t"/></para>
        </entry>
      </row>
    </tbody>
  </tgroup>
</informaltable>
&return-value-dvb;
</section>
</section>
