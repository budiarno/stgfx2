--- a/linux/drivers/media/sysfs/stm/player_sysfs.c	
+++ a/linux/drivers/media/sysfs/stm/player_sysfs.c	
@@ -29,6 +29,7 @@ license from ST.
 
 #define PLAYBACK_MAX_NUMBER     8
 #define STREAM_MAX_NUMBER       16
+#define DEFAULT_ERR_THRESHOLD   5
 
 static int PlayerSetEvent (struct player_event_s*       Event);
 static struct mutex SysfsWriteLock;
@@ -76,14 +77,32 @@ static int                      playback_count          = 0;
 /*{{{  Player2 class and its intimate attributes*/
 
 static unsigned long notify_count = 0;
+static unsigned int  err_threshold = DEFAULT_ERR_THRESHOLD;
 
 static ssize_t show_notify_count(struct class *cls, char *buf)
 {
 	return sprintf(buf, "%lu\n", notify_count);
 }
 
+static ssize_t show_err_threshold(struct class *cls, char *buf)
+{
+	return sprintf(buf, "%u\n", err_threshold);
+}
+
+unsigned int player_sysfs_get_err_threshold()
+{
+    return err_threshold;
+}
+
+static ssize_t store_err_threshold(struct class *cls, char *buf)
+{
+	sscanf(buf, "%i\n", &err_threshold);
+    return sizeof(err_threshold);
+
+}
 static struct class_attribute player2_class_attributes[] = {
 	__ATTR(notify, 0400, show_notify_count, NULL),
+	__ATTR(err_threshold, 0644, show_err_threshold, store_err_threshold),
 	__ATTR_NULL,
 };
 
@@ -819,3 +838,4 @@ EXPORT_SYMBOL(player_sysfs_get_class_device);
 EXPORT_SYMBOL(player_sysfs_get_player_class);
 EXPORT_SYMBOL(player_sysfs_get_stream_id);
 EXPORT_SYMBOL(player_sysfs_new_attribute_notification);
+EXPORT_SYMBOL(player_sysfs_get_err_threshold);
--- a/player/class_definitions/manifestor.h	
+++ a/player/class_definitions/manifestor.h	
@@ -49,6 +49,7 @@ enum
     ManifestorUnplayable                       = BASE_MANIFESTOR,
     ManifestorWouldBlock,
     ManifestorNullQueued,
+    ManifestorDecodeError,
 };
 
 typedef PlayerStatus_t  ManifestorStatus_t;
--- a/player/class_definitions/predefined_metadata_types.h	
+++ a/player/class_definitions/predefined_metadata_types.h	
@@ -341,6 +341,7 @@ typedef struct ParsedAudioParameters_s
 {
     AudioSurfaceParameters_t       Source;
     unsigned int                   SampleCount;
+    int                            decErrorStatus;
     int                            Organisation;     ///< Indicates the organisation of the channels (e.g. 5.1, 2.0)
     AudioOriginalEncoding_t        OriginalEncoding;
     StreamMetadata_t               StreamMetadata;   ///< Stream metadata mainly used by fatpipe 
--- a/player/codec/codec_mme_audio_eac3.cpp	
+++ a/player/codec/codec_mme_audio_eac3.cpp	
@@ -476,6 +476,7 @@ int TranscodedBufferSize = 0;
     AudioParameters->Organisation = Status.AudioMode;
 
     AudioParameters->SampleCount = Status.NbOutSamples;
+    AudioParameters->decErrorStatus = Status.DecStatus;
 
     int SamplingFreqCode = Status.SamplingFreq;
 
--- a/player/manifestor/manifestor_audio.cpp	
+++ a/player/manifestor/manifestor_audio.cpp	
@@ -383,8 +383,11 @@ ManifestorStatus_t      Manifestor_Audio_c::QueueDecodeBuffer   (class Buffer_c*
     Status = QueueBuffer (BufferIndex);
     if (Status != ManifestorNoError)
     {
-	MANIFESTOR_ERROR("Unable to queue buffer %x.\n", Status);
-	return Status;
+        if (Status != ManifestorDecodeError)
+        {
+            MANIFESTOR_ERROR("Unable to queue buffer %x.\n", Status);
+        }
+        return Status;
     }
 
     //
--- a/player/manifestor/manifestor_audio_ksound.cpp	
+++ a/player/manifestor/manifestor_audio_ksound.cpp	
@@ -55,6 +55,8 @@ Date        Modification                                    Name
 #undef  MANIFESTOR_TAG
 #define MANIFESTOR_TAG          "Manifestor_AudioKsound_c::"
 
+extern "C" unsigned int player_sysfs_get_err_threshold();
+
 // /////////////////////////////////////////////////////////////////////////
 //
 // static definitions
@@ -476,16 +478,40 @@ unsigned long long WallTime;
 ///
 ManifestorStatus_t Manifestor_AudioKsound_c::QueueBuffer        (unsigned int                    BufferIndex)
 {
-ManifestorStatus_t Status;
+    ManifestorStatus_t Status;
+    static uint32_t    numGoodFrames = 0;
+    bool               errorFrameSeen = 0;
 
     ParsedFrameParameters_t *FrameParameters = StreamBuffer[BufferIndex].FrameParameters;
 
-    //AudioOutputTiming_t *AudioOutputTiming = StreamBuffer[BufferIndex].AudioOutputTiming;
+    /* Hysterisis:
+     * 1. Stop queuing samples on decode error.
+     * 2. Keep counting good frames on no decode error.
+     * 3. When the good frame count reaches threshold start queuing.
+     */
+    ParsedAudioParameters_t *AudioParameters = StreamBuffer[BufferIndex].AudioParameters;
+    if ( AudioParameters->decErrorStatus )
+    {
+        errorFrameSeen = true;
+        numGoodFrames = 0;
+        return ManifestorDecodeError;
+    }
+    else
+    {
+       numGoodFrames++;
+       if ( numGoodFrames > 5 )
+       {
+           errorFrameSeen = false;
+       }
+       else if (errorFrameSeen)
+       {
+           return ManifestorDecodeError;
+       }
+    }
 
     //
     // Dump the first four samples of the buffer (assuming it to be a ten channel buffer)
     //
-   
     if (0) {
         unsigned char *Data = StreamBuffer[BufferIndex].Data;
         ParsedAudioParameters_t *AudioParameters = StreamBuffer[BufferIndex].AudioParameters;
@@ -1788,6 +1814,8 @@ ManifestorStatus_t Manifestor_AudioKsound_c::FillOutCodedDataBuffer( MME_DataBuf
 {
 BufferStatus_t Status;
 bool MuteRequestAsserted = false;
+bool  errorFrameSeen = false;
+static unsigned int  numGoodFrames = 0;
 
     //
     // Locate any new buffers in the PCM queue and append them to the coded queue.
@@ -1892,6 +1920,34 @@ bool MuteRequestAsserted = false;
                 break;
             }
 
+            /* Hysterisis:
+             * 1. Stop queuing samples on decode error.
+             * 2. Keep counting good frames on no decode error.
+             * 3. When the good frame count reaches threshold start queuing.
+             */
+            {
+                ParsedAudioParameters_t *AudioParameters = StreamBuffer[BufferIndex].AudioParameters;
+                if ( AudioParameters->decErrorStatus )
+                {
+                    errorFrameSeen = true;
+                    numGoodFrames  = 0;
+                    return ManifestorDecodeError;
+                }
+                else
+                {
+                    numGoodFrames++;
+                    if ( numGoodFrames > player_sysfs_get_err_threshold())
+                    {
+                        errorFrameSeen = false;
+                    }
+                    else if (errorFrameSeen)
+                    {
+                        MANIFESTOR_ERROR( "Skipping Buffer goodFrames = %d \n", numGoodFrames );
+                        break;
+                    }
+                }
+            }
+
             // ensure the buffer remains valid for as long as we need
             Status = CodedFrameBuffer->IncrementReferenceCount( IdentifierManifestor );
             if( BufferNoError != Status  )
-- 
